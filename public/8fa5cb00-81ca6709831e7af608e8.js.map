{"version":3,"file":"8fa5cb00-81ca6709831e7af608e8.js","mappings":"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","sources":["webpack://root/./node_modules/@miksu/prettier/lib/language-js/printer-estree.js"],"sourcesContent":["\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar assert = require(\"assert\"); // TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\nvar comments = require(\"../main/comments\");\n\nvar _require = require(\"../common/util\"),\n    getParentExportDeclaration = _require.getParentExportDeclaration,\n    isExportDeclaration = _require.isExportDeclaration,\n    shouldFlatten = _require.shouldFlatten,\n    getNextNonSpaceNonCommentCharacter = _require.getNextNonSpaceNonCommentCharacter,\n    hasNewline = _require.hasNewline,\n    hasNewlineInRange = _require.hasNewlineInRange,\n    getLast = _require.getLast,\n    getStringWidth = _require.getStringWidth,\n    printString = _require.printString,\n    printNumber = _require.printNumber,\n    hasIgnoreComment = _require.hasIgnoreComment,\n    skipWhitespace = _require.skipWhitespace,\n    hasNodeIgnoreComment = _require.hasNodeIgnoreComment,\n    getPenultimate = _require.getPenultimate,\n    startsWithNoLookaheadToken = _require.startsWithNoLookaheadToken,\n    getIndentSize = _require.getIndentSize,\n    matchAncestorTypes = _require.matchAncestorTypes,\n    getPreferredQuote = _require.getPreferredQuote;\n\nvar _require2 = require(\"../common/util-shared\"),\n    isNextLineEmpty = _require2.isNextLineEmpty,\n    isNextLineEmptyAfterIndex = _require2.isNextLineEmptyAfterIndex,\n    getNextNonSpaceNonCommentCharacterIndex = _require2.getNextNonSpaceNonCommentCharacterIndex;\n\nvar isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;\n\nvar embed = require(\"./embed\");\n\nvar clean = require(\"./clean\");\n\nvar insertPragma = require(\"./pragma\").insertPragma;\n\nvar handleComments = require(\"./comments\");\n\nvar pathNeedsParens = require(\"./needs-parens\");\n\nvar _require3 = require(\"./html-binding\"),\n    printHtmlBinding = _require3.printHtmlBinding,\n    isVueEventBindingExpression = _require3.isVueEventBindingExpression;\n\nvar preprocess = require(\"./preprocess\");\n\nvar _require4 = require(\"./utils\"),\n    getLeftSide = _require4.getLeftSide,\n    getLeftSidePathName = _require4.getLeftSidePathName,\n    hasNakedLeftSide = _require4.hasNakedLeftSide,\n    hasNode = _require4.hasNode,\n    hasFlowAnnotationComment = _require4.hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment = _require4.hasFlowShorthandAnnotationComment;\n\nvar needsQuoteProps = new WeakMap();\n\nvar _require5 = require(\"../doc\"),\n    _require5$builders = _require5.builders,\n    concat = _require5$builders.concat,\n    join = _require5$builders.join,\n    line = _require5$builders.line,\n    hardline = _require5$builders.hardline,\n    softline = _require5$builders.softline,\n    literalline = _require5$builders.literalline,\n    group = _require5$builders.group,\n    indent = _require5$builders.indent,\n    align = _require5$builders.align,\n    conditionalGroup = _require5$builders.conditionalGroup,\n    fill = _require5$builders.fill,\n    ifBreak = _require5$builders.ifBreak,\n    breakParent = _require5$builders.breakParent,\n    lineSuffixBoundary = _require5$builders.lineSuffixBoundary,\n    addAlignmentToDoc = _require5$builders.addAlignmentToDoc,\n    dedent = _require5$builders.dedent,\n    _require5$utils = _require5.utils,\n    willBreak = _require5$utils.willBreak,\n    isLineNext = _require5$utils.isLineNext,\n    isEmpty = _require5$utils.isEmpty,\n    removeLines = _require5$utils.removeLines,\n    printDocToString = _require5.printer.printDocToString;\n\nvar uid = 0;\n\nfunction shouldPrintComma(options, level) {\n  level = level || \"es5\";\n\n  switch (options.trailingComma) {\n    case \"all\":\n      if (level === \"all\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"es5\":\n      if (level === \"es5\") {\n        return true;\n      }\n\n    // fallthrough\n\n    case \"none\":\n    default:\n      return false;\n  }\n}\n\nfunction genericPrint(path, options, printPath, args) {\n  var node = path.getValue();\n  var needsParens = false;\n  var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n  if (!node || isEmpty(linesWithoutParens)) {\n    return linesWithoutParens;\n  }\n\n  var parentExportDecl = getParentExportDeclaration(path);\n  var decorators = [];\n\n  if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") {// their decorators are handled themselves\n  } else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n  // was written before the export, the export will be responsible\n  // for printing the decorators.\n  !(parentExportDecl && options.locStart(parentExportDecl, {\n    ignoreDecorators: true\n  }) > options.locStart(node.decorators[0]))) {\n    var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators(node, options);\n    var separator = shouldBreak ? hardline : line;\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n\n      if (decorator.expression) {\n        decorator = decorator.expression;\n      } else {\n        decorator = decorator.callee;\n      }\n\n      decorators.push(printPath(decoratorPath), separator);\n    }, \"decorators\");\n\n    if (parentExportDecl) {\n      decorators.unshift(hardline);\n    }\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n  // otherwise they are printed by the node.declaration\n  options.locStart(node, {\n    ignoreDecorators: true\n  }) > options.locStart(node.declaration.decorators[0])) {\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n    path.each(function (decoratorPath) {\n      var decorator = decoratorPath.getValue();\n      var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n      decorators.push(prefix, printPath(decoratorPath), hardline);\n    }, \"declaration\", \"decorators\");\n  } else {\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n    needsParens = pathNeedsParens(path, options);\n  }\n\n  var parts = [];\n\n  if (needsParens) {\n    parts.unshift(\"(\");\n  }\n\n  parts.push(linesWithoutParens);\n\n  if (needsParens) {\n    var _node = path.getValue();\n\n    if (hasFlowShorthandAnnotationComment(_node)) {\n      parts.push(\" /*\");\n      parts.push(_node.trailingComments[0].value.trimLeft());\n      parts.push(\"*/\");\n      _node.trailingComments[0].printed = true;\n    }\n\n    parts.push(\")\");\n  }\n\n  if (decorators.length > 0) {\n    return group(concat(decorators.concat(parts)));\n  }\n\n  return concat(parts);\n}\n\nfunction hasNewlineBetweenOrAfterDecorators(node, options) {\n  return hasNewlineInRange(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast(node.decorators))) || hasNewline(options.originalText, options.locEnd(getLast(node.decorators)));\n}\n\nfunction printDecorators(path, options, print) {\n  var node = path.getValue();\n  return group(concat([join(line, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]));\n}\n\nfunction hasPrettierIgnore(path) {\n  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n}\n\nfunction hasJsxIgnoreComment(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n    return false;\n  } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  var index = parent.children.indexOf(node);\n  var prevSibling = null;\n\n  for (var i = index; i > 0; i--) {\n    var candidate = parent.children[i - 1];\n\n    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n      continue;\n    }\n\n    prevSibling = candidate;\n    break;\n  }\n\n  return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  });\n}\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\nfunction printTernaryOperator(path, options, print, operatorOptions) {\n  var node = path.getValue();\n  var testNode = node[operatorOptions.testNodePropertyName];\n  var consequentNode = node[operatorOptions.consequentNodePropertyName];\n  var alternateNode = node[operatorOptions.alternateNodePropertyName];\n  var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n  var jsxMode = false;\n  var parent = path.getParentNode();\n  var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n  var currentParent;\n  var previousParent;\n  var i = 0;\n\n  do {\n    previousParent = currentParent || node;\n    currentParent = path.getParentNode(i);\n    i++;\n  } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n  var firstNonConditionalParent = currentParent || parent;\n  var lastConditionalParent = previousParent;\n\n  if (operatorOptions.shouldCheckJsx && (isJSXNode(testNode) || isJSXNode(consequentNode) || isJSXNode(alternateNode) || conditionalExpressionChainContainsJSX(lastConditionalParent))) {\n    jsxMode = true;\n    forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n    var wrap = function wrap(doc) {\n      return concat([ifBreak(\"(\", \"\"), indent(concat([softline, doc])), softline, ifBreak(\")\", \"\")]);\n    }; // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n\n\n    var isNull = function isNull(node) {\n      return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n    };\n\n    parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n  } else {\n    // normal mode\n    var part = concat([line, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \"(\") : \"\", align(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak(\"\", \")\") : \"\", line, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n    parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n  } // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  var maybeGroup = function maybeGroup(doc) {\n    return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group(doc) : doc : group(doc);\n  }; // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n  var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && !parent.computed;\n  return maybeGroup(concat([].concat(function (testDoc) {\n    return (\n      /**\n       *     a\n       *       ? b\n       *       : multiline\n       *         test\n       *         node\n       *       ^^ align(2)\n       *       ? d\n       *       : e\n       */\n      parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align(2, testDoc) : testDoc\n    );\n  }(concat(operatorOptions.beforeParts())), forceNoIndent ? concat(parts) : indent(concat(parts)), operatorOptions.afterParts(breakClosingParen))));\n}\n\nfunction getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n  if (tokenNode === \"+\") {\n    return \"+\" + keyword;\n  } else if (tokenNode === \"-\") {\n    return \"-\" + keyword;\n  }\n\n  return keyword;\n}\n\nfunction printPathNoParens(path, options, print, args) {\n  var n = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n\n  if (!n) {\n    return \"\";\n  }\n\n  if (typeof n === \"string\") {\n    return n;\n  }\n\n  var htmlBinding = printHtmlBinding(path, options, print);\n\n  if (htmlBinding) {\n    return htmlBinding;\n  }\n\n  var parts = [];\n\n  switch (n.type) {\n    case \"JsExpressionRoot\":\n      return path.call(print, \"node\");\n\n    case \"JsonRoot\":\n      return concat([path.call(print, \"node\"), hardline]);\n\n    case \"File\":\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n      if (n.program && n.program.interpreter) {\n        parts.push(path.call(function (programPath) {\n          return programPath.call(print, \"interpreter\");\n        }, \"program\"));\n      }\n\n      parts.push(path.call(print, \"program\"));\n      return concat(parts);\n\n    case \"Program\":\n      // Babel 6\n      if (n.directives) {\n        path.each(function (childPath) {\n          parts.push(print(childPath), semi, hardline);\n\n          if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n            parts.push(hardline);\n          }\n        }, \"directives\");\n      }\n\n      parts.push(path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\"));\n      parts.push(comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true)); // Only force a trailing newline if there were any contents.\n\n      if (n.body.length || n.comments) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n    // Babel extension.\n\n    case \"EmptyStatement\":\n      return \"\";\n\n    case \"ExpressionStatement\":\n      // Detect Flow-parsed directives\n      if (n.directive) {\n        return concat([nodeStr(n.expression, options, true), semi]);\n      }\n\n      if (options.parser === \"__vue_event_binding\") {\n        var parent = path.getParentNode();\n\n        if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n          return concat([path.call(print, \"expression\"), isVueEventBindingExpression(n.expression) ? \";\" : \"\"]);\n        }\n      } // Do not append semicolon after the only JSX element in a program\n\n\n      return concat([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi]);\n    // Babel extension.\n\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"AssignmentExpression\":\n      return printAssignment(n.left, path.call(print, \"left\"), concat([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"NGPipeExpression\":\n      {\n        var _parent = path.getParentNode();\n\n        var parentParent = path.getParentNode(1);\n        var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"DoWhileStatement\");\n\n        var _parts = printBinaryishExpressions(path, print, options,\n        /* isNested */\n        false, isInsideParenthesis); //   if (\n        //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n        //   ) {\n        //\n        // looks super weird, we want to break the children if the parent breaks\n        //\n        //   if (\n        //     this.hasPlugin(\"dynamicImports\") &&\n        //     this.lookahead().type === tt.parenLeft\n        //   ) {\n\n\n        if (isInsideParenthesis) {\n          return concat(_parts);\n        } // Break between the parens in\n        // unaries or in a member or specific call expression, i.e.\n        //\n        //   (\n        //     a &&\n        //     b &&\n        //     c\n        //   ).call()\n\n\n        if (_parent.type === \"CallExpression\" && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n          return group(concat([indent(concat([softline, concat(_parts)])), softline]));\n        } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n        // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n        var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\";\n        var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n        var samePrecedenceSubExpression = isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);\n\n        if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n          return group(concat(_parts));\n        }\n\n        if (_parts.length === 0) {\n          return \"\";\n        } // If the right part is a JSX node, we include it in a separate group to\n        // prevent it breaking the whole chain, so we can print the expression like:\n        //\n        //   foo && bar && (\n        //     <Foo>\n        //       <Bar />\n        //     </Foo>\n        //   )\n\n\n        var hasJSX = isJSXNode(n.right);\n        var rest = concat(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n        var groupId = Symbol(\"logicalChain-\" + ++uid);\n        var chain = group(concat([// Don't include the initial expression in the indentation\n        // level. The first item is guaranteed to be the first\n        // left-most expression.\n        _parts.length > 0 ? _parts[0] : \"\", indent(rest)]), {\n          id: groupId\n        });\n\n        if (!hasJSX) {\n          return chain;\n        }\n\n        var jsxPart = getLast(_parts);\n        return group(concat([chain, ifBreak(indent(jsxPart), jsxPart, {\n          groupId: groupId\n        })]));\n      }\n\n    case \"AssignmentPattern\":\n      return concat([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n    case \"TSTypeAssertion\":\n      {\n        var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n        var castGroup = group(concat([\"<\", indent(concat([softline, path.call(print, \"typeAnnotation\")])), softline, \">\"]));\n        var exprContents = concat([ifBreak(\"(\"), indent(concat([softline, path.call(print, \"expression\")])), softline, ifBreak(\")\")]);\n\n        if (shouldBreakAfterCast) {\n          return conditionalGroup([concat([castGroup, path.call(print, \"expression\")]), concat([castGroup, group(exprContents, {\n            shouldBreak: true\n          })]), concat([castGroup, path.call(print, \"expression\")])]);\n        }\n\n        return group(concat([castGroup, path.call(print, \"expression\")]));\n      }\n\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        var _parent2 = path.getParentNode();\n\n        var firstNonMemberParent;\n        var i = 0;\n\n        do {\n          firstNonMemberParent = path.getParentNode(i);\n          i++;\n        } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n        var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n        return concat([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group(indent(concat([softline, printMemberLookup(path, options, print)])))]);\n      }\n\n    case \"MetaProperty\":\n      return concat([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n\n      parts.push(group(indent(concat([softline, printBindExpressionCallee(path, options, print)]))));\n      return concat(parts);\n\n    case \"Identifier\":\n      {\n        return concat([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      }\n\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"RestElement\":\n    case \"ObjectTypeSpreadProperty\":\n      return concat([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      parts.push(printFunctionDeclaration(path, print, options));\n\n      if (!n.body) {\n        parts.push(semi);\n      }\n\n      return concat(parts);\n\n    case \"ArrowFunctionExpression\":\n      {\n        if (n.async) {\n          parts.push(\"async \");\n        }\n\n        if (shouldPrintParamsWithoutParens(path, options)) {\n          parts.push(path.call(print, \"params\", 0));\n        } else {\n          parts.push(group(concat([printFunctionParams(path, print, options,\n          /* expandLast */\n          args && (args.expandLastArg || args.expandFirstArg),\n          /* printTypeParams */\n          true), printReturnType(path, print, options)])));\n        }\n\n        var dangling = comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true, function (comment) {\n          var nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, options);\n          return options.originalText.substr(nextCharacter, 2) === \"=>\";\n        });\n\n        if (dangling) {\n          parts.push(\" \", dangling);\n        }\n\n        parts.push(\" =>\");\n        var body = path.call(function (bodyPath) {\n          return print(bodyPath, args);\n        }, \"body\"); // We want to always keep these types of nodes on the same line\n        // as the arrow.\n\n        if (!hasLeadingOwnLineComment(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode(n.body) || isTemplateOnItsOwnLine(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n          return group(concat([concat(parts), \" \", body]));\n        } // We handle sequence expressions as the body of arrows specially,\n        // so that the required parentheses end up on their own lines.\n\n\n        if (n.body.type === \"SequenceExpression\") {\n          return group(concat([concat(parts), group(concat([\" (\", indent(concat([softline, body])), softline, \")\"]))]));\n        } // if the arrow function is expanded as last argument, we are adding a\n        // level of indentation and need to add a softline to align the closing )\n        // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n        // we should align the expression's closing } with the line with the opening {.\n\n\n        var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n        var printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, \"all\"); // In order to avoid confusion between\n        // a => a ? a : a\n        // a <= a ? a : a\n\n        var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken(n.body,\n        /* forbidFunctionAndClass */\n        false);\n        return group(concat([concat(parts), group(concat([indent(concat([line, shouldAddParens ? ifBreak(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline]) : \"\"]))]));\n      }\n\n    case \"MethodDefinition\":\n    case \"TSAbstractMethodDefinition\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.type === \"TSAbstractMethodDefinition\") {\n        parts.push(\"abstract \");\n      }\n\n      parts.push(printMethod(path, options, print));\n      return concat(parts);\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n\n      if (n.delegate) {\n        parts.push(\"*\");\n      }\n\n      if (n.argument) {\n        parts.push(\" \", path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"AwaitExpression\":\n      return concat([\"await \", path.call(print, \"argument\")]);\n\n    case \"ImportSpecifier\":\n      if (n.importKind) {\n        parts.push(path.call(print, \"importKind\"), \" \");\n      }\n\n      parts.push(path.call(print, \"imported\"));\n\n      if (n.local && n.local.name !== n.imported.name) {\n        parts.push(\" as \", path.call(print, \"local\"));\n      }\n\n      return concat(parts);\n\n    case \"ExportSpecifier\":\n      parts.push(path.call(print, \"local\"));\n\n      if (n.exported && n.exported.name !== n.local.name) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n\n      return concat(parts);\n\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      parts.push(path.call(print, \"local\"));\n      return concat(parts);\n\n    case \"ImportDefaultSpecifier\":\n      return path.call(print, \"local\");\n\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\"), semi]);\n\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n\n    case \"ExportAllDeclaration\":\n      parts.push(\"export \");\n\n      if (n.exportKind === \"type\") {\n        parts.push(\"type \");\n      }\n\n      parts.push(\"* from \", path.call(print, \"source\"), semi);\n      return concat(parts);\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n\n    case \"ImportDeclaration\":\n      {\n        parts.push(\"import \");\n\n        if (n.importKind && n.importKind !== \"value\") {\n          parts.push(n.importKind + \" \");\n        }\n\n        var standalones = [];\n        var grouped = [];\n\n        if (n.specifiers && n.specifiers.length > 0) {\n          path.each(function (specifierPath) {\n            var value = specifierPath.getValue();\n\n            if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n              standalones.push(print(specifierPath));\n            } else {\n              grouped.push(print(specifierPath));\n            }\n          }, \"specifiers\");\n\n          if (standalones.length > 0) {\n            parts.push(join(\", \", standalones));\n          }\n\n          if (standalones.length > 0 && grouped.length > 0) {\n            parts.push(\", \");\n          }\n\n          if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n            return node.comments;\n          })) {\n            parts.push(concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n          } else if (grouped.length >= 1) {\n            parts.push(group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), grouped)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"])));\n          }\n\n          parts.push(\" from \");\n        } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n        /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n          parts.push(\"{} from \");\n        }\n\n        parts.push(path.call(print, \"source\"), semi);\n        return concat(parts);\n      }\n\n    case \"Import\":\n      return \"import\";\n\n    case \"TSModuleBlock\":\n    case \"BlockStatement\":\n      {\n        var naked = path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\");\n        var hasContent = n.body.find(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n        var hasDirectives = n.directives && n.directives.length > 0;\n\n        var _parent3 = path.getParentNode();\n\n        var _parentParent = path.getParentNode(1);\n\n        if (!hasContent && !hasDirectives && !hasDanglingComments(n) && (_parent3.type === \"ArrowFunctionExpression\" || _parent3.type === \"FunctionExpression\" || _parent3.type === \"FunctionDeclaration\" || _parent3.type === \"ObjectMethod\" || _parent3.type === \"ClassMethod\" || _parent3.type === \"ClassPrivateMethod\" || _parent3.type === \"ForStatement\" || _parent3.type === \"WhileStatement\" || _parent3.type === \"DoWhileStatement\" || _parent3.type === \"DoExpression\" || _parent3.type === \"CatchClause\" && !_parentParent.finalizer || _parent3.type === \"TSModuleDeclaration\")) {\n          return \"{}\";\n        }\n\n        parts.push(\"{\"); // Babel 6\n\n        if (hasDirectives) {\n          path.each(function (childPath) {\n            parts.push(indent(concat([hardline, print(childPath), semi])));\n\n            if (isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }, \"directives\");\n        }\n\n        if (hasContent) {\n          parts.push(indent(concat([hardline, naked])));\n        }\n\n        parts.push(comments.printDanglingComments(path, options));\n        parts.push(hardline, \"}\");\n        return concat(parts);\n      }\n\n    case \"ReturnStatement\":\n      parts.push(\"return\");\n\n      if (n.argument) {\n        if (returnArgumentHasLeadingComment(options, n.argument)) {\n          parts.push(concat([\" (\", indent(concat([hardline, path.call(print, \"argument\")])), hardline, \")\"]));\n        } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n          parts.push(group(concat([ifBreak(\" (\", \" \"), indent(concat([softline, path.call(print, \"argument\")])), softline, ifBreak(\")\")])));\n        } else {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n      }\n\n      if (hasDanglingComments(n)) {\n        parts.push(\" \", comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"NewExpression\":\n    case \"OptionalCallExpression\":\n    case \"CallExpression\":\n      {\n        var isNew = n.type === \"NewExpression\";\n        var optional = printOptionalToken(path);\n\n        if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n        !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n        n.arguments.length === 1 && isTemplateOnItsOwnLine(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n        !isNew && isTestCall(n, path.getParentNode())) {\n          return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])]);\n        } // Inline Flow annotation comments following Identifiers in Call nodes need to\n        // stay with the Identifier. For example:\n        //\n        // foo /*:: <SomeGeneric> */(bar);\n        //\n        // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n        var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment(n.callee.trailingComments);\n\n        if (isIdentifierWithFlowAnnotation) {\n          n.callee.trailingComments[0].printed = true;\n        } // We detect calls on member lookups and possibly print them in a\n        // special chain format. See `printMemberChain` for more info.\n\n\n        if (!isNew && isMemberish(n.callee)) {\n          return printMemberChain(path, options, print);\n        }\n\n        return concat([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n      }\n\n    case \"TSInterfaceDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(n[\"abstract\"] ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n      if (n[\"extends\"] && n[\"extends\"].length) {\n        parts.push(group(indent(concat([softline, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\"))), \" \"]))));\n      }\n\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n\n    case \"ObjectTypeInternalSlot\":\n      return concat([n[\"static\"] ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      {\n        var propertiesField;\n\n        if (n.type === \"TSTypeLiteral\") {\n          propertiesField = \"members\";\n        } else if (n.type === \"TSInterfaceBody\") {\n          propertiesField = \"body\";\n        } else {\n          propertiesField = \"properties\";\n        }\n\n        var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n        var fields = [];\n\n        if (isTypeAnnotation) {\n          fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n        }\n\n        fields.push(propertiesField);\n        var firstProperty = fields.map(function (field) {\n          return n[field][0];\n        }).sort(function (a, b) {\n          return options.locStart(a) - options.locStart(b);\n        })[0];\n\n        var _parent4 = path.getParentNode(0);\n\n        var isFlowInterfaceLikeBody = isTypeAnnotation && _parent4 && (_parent4.type === \"InterfaceDeclaration\" || _parent4.type === \"DeclareInterface\" || _parent4.type === \"DeclareClass\") && path.getName() === \"body\";\n        var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent4.type !== \"FunctionDeclaration\" && _parent4.type !== \"FunctionExpression\" && _parent4.type !== \"ArrowFunctionExpression\" && _parent4.type !== \"AssignmentPattern\" && _parent4.type !== \"CatchClause\" && n.properties.some(function (property) {\n          return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n        }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange(options.originalText, options.locStart(n), options.locStart(firstProperty));\n        var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak(semi, \";\") : \",\";\n        var leftBrace = n.exact ? \"{|\" : \"{\";\n        var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n        // interleaved in the source code. So we need to reorder them before\n        // printing them.\n\n        var propsAndLoc = [];\n        fields.forEach(function (field) {\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n            propsAndLoc.push({\n              node: node,\n              printed: print(childPath),\n              loc: options.locStart(node)\n            });\n          }, field);\n        });\n        var separatorParts = [];\n        var props = propsAndLoc.sort(function (a, b) {\n          return a.loc - b.loc;\n        }).map(function (prop) {\n          var result = concat(separatorParts.concat(group(prop.printed)));\n          separatorParts = [separator, line];\n\n          if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment(prop.node)) {\n            separatorParts.shift();\n          }\n\n          if (isNextLineEmpty(options.originalText, prop.node, options)) {\n            separatorParts.push(hardline);\n          }\n\n          return result;\n        });\n\n        if (n.inexact) {\n          props.push(concat(separatorParts.concat(group(\"...\"))));\n        }\n\n        var lastElem = getLast(n[propertiesField]);\n        var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment(lastElem) || n.inexact));\n        var content;\n\n        if (props.length === 0) {\n          if (!hasDanglingComments(n)) {\n            return concat([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n          }\n\n          content = group(concat([leftBrace, comments.printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n        } else {\n          content = concat([leftBrace, indent(concat([options.bracketSpacing ? line : softline, concat(props)])), ifBreak(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma(options)) ? separator : \"\"), concat([options.bracketSpacing ? line : softline, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        } // If we inline the object as first argument of the parent, we don't want\n        // to create another group so that the object breaks before the return\n        // type\n\n\n        var parentParentParent = path.getParentNode(2);\n\n        if (n.type === \"ObjectPattern\" && _parent4 && shouldHugArguments(_parent4) && !n.decorators && _parent4.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n          return content;\n        }\n\n        return group(content, {\n          shouldBreak: shouldBreak\n        });\n      }\n    // Babel 6\n\n    case \"ObjectProperty\": // Non-standard AST node type.\n\n    case \"Property\":\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n\n      if (n.shorthand) {\n        parts.push(path.call(print, \"value\"));\n      } else {\n        var printedLeft;\n\n        if (n.computed) {\n          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);\n        } else {\n          printedLeft = printPropertyKey(path, options, print);\n        }\n\n        parts.push(printAssignment(n.key, printedLeft, \":\", n.value, path.call(print, \"value\"), options));\n      }\n\n      return concat(parts);\n    // Babel 6\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (n.decorators && n.decorators.length !== 0) {\n        parts.push(printDecorators(path, options, print));\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts = parts.concat(printObjectMethod(path, options, print));\n      return concat(parts);\n    // Babel 6\n\n    case \"ObjectMethod\":\n      return printObjectMethod(path, options, print);\n\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n      if (n.elements.length === 0) {\n        if (!hasDanglingComments(n)) {\n          parts.push(\"[]\");\n        } else {\n          parts.push(group(concat([\"[\", comments.printDanglingComments(path, options), softline, \"]\"])));\n        }\n      } else {\n        var _lastElem = getLast(n.elements);\n\n        var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n        var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n        parts.push(group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"])));\n      }\n\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return concat(parts);\n\n    case \"SequenceExpression\":\n      {\n        var _parent5 = path.getParentNode(0);\n\n        if (_parent5.type === \"ExpressionStatement\" || _parent5.type === \"ForStatement\") {\n          // For ExpressionStatements and for-loop heads, which are among\n          // the few places a SequenceExpression appears unparenthesized, we want\n          // to indent expressions after the first.\n          var _parts2 = [];\n          path.each(function (p) {\n            if (p.getName() === 0) {\n              _parts2.push(print(p));\n            } else {\n              _parts2.push(\",\", indent(concat([line, print(p)])));\n            }\n          }, \"expressions\");\n          return group(concat(_parts2));\n        }\n\n        return group(concat([join(concat([\",\", line]), path.map(print, \"expressions\"))]));\n      }\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"Super\":\n      return \"super\";\n\n    case \"NullLiteral\":\n      // Babel 6 Literal split\n      return \"null\";\n\n    case \"RegExpLiteral\":\n      // Babel 6 Literal split\n      return printRegex(n);\n\n    case \"NumericLiteral\":\n      // Babel 6 Literal split\n      return printNumber(n.extra.raw);\n\n    case \"BigIntLiteral\":\n      return concat([printNumber(n.extra ? n.extra.rawValue : // TypeScript\n      n.value), \"n\"]);\n\n    case \"BooleanLiteral\": // Babel 6 Literal split\n\n    case \"StringLiteral\": // Babel 6 Literal split\n\n    case \"Literal\":\n      {\n        if (n.regex) {\n          return printRegex(n.regex);\n        }\n\n        if (typeof n.value === \"number\") {\n          return printNumber(n.raw);\n        }\n\n        if (typeof n.value !== \"string\") {\n          return \"\" + n.value;\n        } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in needs-parens.js\n\n\n        var grandParent = path.getParentNode(1);\n        var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n        return nodeStr(n, options, isTypeScriptDirective);\n      }\n\n    case \"Directive\":\n      return path.call(print, \"value\");\n    // Babel 6\n\n    case \"DirectiveLiteral\":\n      return nodeStr(n, options);\n\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n\n      if (/[a-z]$/.test(n.operator)) {\n        parts.push(\" \");\n      }\n\n      if (n.argument.comments && n.argument.comments.length > 0) {\n        parts.push(group(concat([\"(\", indent(concat([softline, path.call(print, \"argument\")])), softline, \")\"])));\n      } else {\n        parts.push(path.call(print, \"argument\"));\n      }\n\n      return concat(parts);\n\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n\n      if (n.prefix) {\n        parts.reverse();\n      }\n\n      return concat(parts);\n\n    case \"ConditionalExpression\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"test\")];\n        },\n        afterParts: function afterParts(breakClosingParen) {\n          return [breakClosingParen ? softline : \"\"];\n        },\n        shouldCheckJsx: true,\n        conditionalNodeType: \"ConditionalExpression\",\n        consequentNodePropertyName: \"consequent\",\n        alternateNodePropertyName: \"alternate\",\n        testNodePropertyName: \"test\",\n        breakNested: true\n      });\n\n    case \"VariableDeclaration\":\n      {\n        var printed = path.map(function (childPath) {\n          return print(childPath);\n        }, \"declarations\"); // We generally want to terminate all variable declarations with a\n        // semicolon, except when they in the () part of for loops.\n\n        var parentNode = path.getParentNode();\n        var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n        var hasValue = n.declarations.some(function (decl) {\n          return decl.init;\n        });\n        var firstVariable;\n\n        if (printed.length === 1 && !n.declarations[0].comments) {\n          firstVariable = printed[0];\n        } else if (printed.length > 0) {\n          // Indent first var to comply with eslint one-var rule\n          firstVariable = indent(printed[0]);\n        }\n\n        parts = [isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\", n.kind, firstVariable ? concat([\" \", firstVariable]) : \"\", indent(concat(printed.slice(1).map(function (p) {\n          return concat([\",\", hasValue && !isParentForLoop ? hardline : line, p]);\n        })))];\n\n        if (!(isParentForLoop && parentNode.body !== n)) {\n          parts.push(semi);\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSTypeAliasDeclaration\":\n      {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n        return group(concat(parts));\n      }\n\n    case \"VariableDeclarator\":\n      return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n    case \"WithStatement\":\n      return group(concat([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"IfStatement\":\n      {\n        var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n        var opening = group(concat([\"if (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", con]));\n        parts.push(opening);\n\n        if (n.alternate) {\n          var commentOnOwnLine = hasTrailingComment(n.consequent) && n.consequent.comments.some(function (comment) {\n            return comment.trailing && !handleComments.isBlockComment(comment);\n          }) || needsHardlineAfterDanglingComment(n);\n          var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n          parts.push(elseOnSameLine ? \" \" : hardline);\n\n          if (hasDanglingComments(n)) {\n            parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline : \" \");\n          }\n\n          parts.push(\"else\", group(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n        }\n\n        return concat(parts);\n      }\n\n    case \"ForStatement\":\n      {\n        var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n        // Any comment positioned between the for statement and the parentheses\n        // is going to be printed before the statement.\n\n\n        var _dangling = comments.printDanglingComments(path, options,\n        /* sameLine */\n        true);\n\n        var printedComments = _dangling ? concat([_dangling, softline]) : \"\";\n\n        if (!n.init && !n.test && !n.update) {\n          return concat([printedComments, group(concat([\"for (;;)\", _body]))]);\n        }\n\n        return concat([printedComments, group(concat([\"for (\", group(concat([indent(concat([softline, path.call(print, \"init\"), \";\", line, path.call(print, \"test\"), \";\", line, path.call(print, \"update\")])), softline])), \")\", _body]))]);\n      }\n\n    case \"WhileStatement\":\n      return group(concat([\"while (\", group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForInStatement\":\n      // Note: esprima can't actually parse \"for each (\".\n      return group(concat([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      {\n        // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n        // with `\"await\": true`:\n        // https://github.com/estree/estree/pull/138\n        var isAwait = n.type === \"ForAwaitStatement\" || n[\"await\"];\n        return group(concat([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n      }\n\n    case \"DoWhileStatement\":\n      {\n        var clause = adjustClause(n.body, path.call(print, \"body\"));\n        var doBody = group(concat([\"do\", clause]));\n        parts = [doBody];\n\n        if (n.body.type === \"BlockStatement\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline);\n        }\n\n        parts.push(\"while (\");\n        parts.push(group(concat([indent(concat([softline, path.call(print, \"test\")])), softline])), \")\", semi);\n        return concat(parts);\n      }\n\n    case \"DoExpression\":\n      return concat([\"do \", path.call(print, \"body\")]);\n\n    case \"BreakStatement\":\n      parts.push(\"break\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n\n      if (n.label) {\n        parts.push(\" \", path.call(print, \"label\"));\n      }\n\n      parts.push(semi);\n      return concat(parts);\n\n    case \"LabeledStatement\":\n      if (n.body.type === \"EmptyStatement\") {\n        return concat([path.call(print, \"label\"), \":;\"]);\n      }\n\n      return concat([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n    case \"TryStatement\":\n      return concat([\"try \", path.call(print, \"block\"), n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n    case \"CatchClause\":\n      if (n.param) {\n        var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n          return !handleComments.isBlockComment(comment) || comment.leading && hasNewline(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          });\n        });\n        var param = path.call(print, \"param\");\n        return concat([\"catch \", hasComments ? concat([\"(\", indent(concat([softline, param])), softline, \") \"]) : concat([\"(\", param, \") \"]), path.call(print, \"body\")]);\n      }\n\n      return concat([\"catch \", path.call(print, \"body\")]);\n\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), semi]);\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n    case \"SwitchStatement\":\n      return concat([group(concat([\"switch (\", indent(concat([softline, path.call(print, \"discriminant\")])), softline, \")\"])), \" {\", n.cases.length > 0 ? indent(concat([hardline, join(hardline, path.map(function (casePath) {\n        var caseNode = casePath.getValue();\n        return concat([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty(options.originalText, caseNode, options) ? hardline : \"\"]);\n      }, \"cases\"))])) : \"\", hardline, \"}\"]);\n\n    case \"SwitchCase\":\n      {\n        if (n.test) {\n          parts.push(\"case \", path.call(print, \"test\"), \":\");\n        } else {\n          parts.push(\"default:\");\n        }\n\n        var consequent = n.consequent.filter(function (node) {\n          return node.type !== \"EmptyStatement\";\n        });\n\n        if (consequent.length > 0) {\n          var cons = path.call(function (consequentPath) {\n            return printStatementSequence(consequentPath, options, print);\n          }, \"consequent\");\n          parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat([\" \", cons]) : indent(concat([hardline, cons])));\n        }\n\n        return concat(parts);\n      }\n    // JSX extensions below.\n\n    case \"DebuggerStatement\":\n      return concat([\"debugger\", semi]);\n\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n\n      if (n.value) {\n        var res;\n\n        if (isStringLiteral(n.value)) {\n          var raw = rawText(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n          var _final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n\n          var quote = getPreferredQuote(_final, options.jsxSingleQuote ? \"'\" : '\"');\n\n          var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n          _final = _final.replace(new RegExp(quote, \"g\"), _escape);\n          res = concat([quote, _final, quote]);\n        } else {\n          res = path.call(print, \"value\");\n        }\n\n        parts.push(\"=\", res);\n      }\n\n      return concat(parts);\n\n    case \"JSXIdentifier\":\n      return \"\" + n.name;\n\n    case \"JSXNamespacedName\":\n      return join(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n    case \"JSXMemberExpression\":\n      return join(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n    case \"TSQualifiedName\":\n      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n    case \"JSXSpreadAttribute\":\n    case \"JSXSpreadChild\":\n      {\n        return concat([\"{\", path.call(function (p) {\n          var printed = concat([\"...\", print(p)]);\n          var n = p.getValue();\n\n          if (!n.comments || !n.comments.length) {\n            return printed;\n          }\n\n          return concat([indent(concat([softline, comments.printComments(p, function () {\n            return printed;\n          }, options)])), softline]);\n        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n      }\n\n    case \"JSXExpressionContainer\":\n      {\n        var _parent6 = path.getParentNode(0);\n\n        var preventInline = _parent6.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n        var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode(_parent6) && (n.expression.type === \"ConditionalExpression\" || isBinaryish(n.expression)));\n\n        if (_shouldInline) {\n          return group(concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"]));\n        }\n\n        return group(concat([\"{\", indent(concat([softline, path.call(print, \"expression\")])), softline, lineSuffixBoundary, \"}\"]));\n      }\n\n    case \"JSXFragment\":\n    case \"JSXElement\":\n      {\n        var elem = comments.printComments(path, function () {\n          return printJSXElement(path, options, print);\n        }, options);\n        return maybeWrapJSXElementInParens(path, elem);\n      }\n\n    case \"JSXOpeningElement\":\n      {\n        var _n = path.getValue();\n\n        var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n        if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n          return concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n        } // don't break up opening elements with a single long text attribute\n\n\n        if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n        !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n          return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n        }\n\n        var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment(getLast(_n.attributes));\n        var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n        !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n        // <div\n        //   // comment\n        // >\n        // <div\n        //   attr // comment\n        // >\n        !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n        // string literal with newlines\n\n        var _shouldBreak = _n.attributes && _n.attributes.some(function (attr) {\n          return attr.value && isStringLiteral(attr.value) && attr.value.value.includes(\"\\n\");\n        });\n\n        return group(concat([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat([indent(concat(path.map(function (attr) {\n          return concat([line, print(attr)]);\n        }, \"attributes\"))), _n.selfClosing ? line : bracketSameLine ? \">\" : softline]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n          shouldBreak: _shouldBreak\n        });\n      }\n\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      {\n        var hasComment = n.comments && n.comments.length;\n        var hasOwnLineComment = hasComment && !n.comments.every(handleComments.isBlockComment);\n        var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n        return concat([isOpeningFragment ? \"<\" : \"</\", indent(concat([hasOwnLineComment ? hardline : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline : \"\", \">\"]);\n      }\n\n    case \"JSXText\":\n      /* istanbul ignore next */\n      throw new Error(\"JSXTest should be handled by JSXElement\");\n\n    case \"JSXEmptyExpression\":\n      {\n        var requiresHardline = n.comments && !n.comments.every(handleComments.isBlockComment);\n        return concat([comments.printDanglingComments(path, options,\n        /* sameIndent */\n        !requiresHardline), requiresHardline ? hardline : \"\"]);\n      }\n\n    case \"ClassBody\":\n      if (!n.comments && n.body.length === 0) {\n        return \"{}\";\n      }\n\n      return concat([\"{\", n.body.length > 0 ? indent(concat([hardline, path.call(function (bodyPath) {\n        return printStatementSequence(bodyPath, options, print);\n      }, \"body\")])) : comments.printDanglingComments(path, options), hardline, \"}\"]);\n\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n    case \"ClassPrivateProperty\":\n      {\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractClassProperty\") {\n          parts.push(\"abstract \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        var variance = getFlowVariance(n);\n\n        if (variance) {\n          parts.push(variance);\n        }\n\n        if (n.computed) {\n          parts.push(\"[\", path.call(print, \"key\"), \"]\");\n        } else {\n          parts.push(printPropertyKey(path, options, print));\n        }\n\n        parts.push(printOptionalToken(path));\n        parts.push(printTypeAnnotation(path, options, print));\n\n        if (n.value) {\n          parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n        }\n\n        parts.push(semi);\n        return group(concat(parts));\n      }\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      parts.push(concat(printClass(path, options, print)));\n      return concat(parts);\n\n    case \"TSInterfaceHeritage\":\n      parts.push(path.call(print, \"expression\"));\n\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n\n      return concat(parts);\n\n    case \"TemplateElement\":\n      return join(literalline, n.value.raw.split(/\\r?\\n/g));\n\n    case \"TemplateLiteral\":\n      {\n        var expressions = path.map(print, \"expressions\");\n\n        var _parentNode = path.getParentNode();\n\n        if (isJestEachTemplateLiteral(n, _parentNode)) {\n          var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n          if (_printed2) {\n            return _printed2;\n          }\n        }\n\n        var isSimple = isSimpleTemplateLiteral(n);\n\n        if (isSimple) {\n          expressions = expressions.map(function (doc) {\n            return printDocToString(doc, Object.assign({}, options, {\n              printWidth: Infinity\n            })).formatted;\n          });\n        }\n\n        parts.push(lineSuffixBoundary, \"`\");\n        path.each(function (childPath) {\n          var i = childPath.getName();\n          parts.push(print(childPath));\n\n          if (i < expressions.length) {\n            // For a template literal of the following form:\n            //   `someQuery {\n            //     ${call({\n            //       a,\n            //       b,\n            //     })}\n            //   }`\n            // the expression is on its own line (there is a \\n in the previous\n            // quasi literal), therefore we want to indent the JavaScript\n            // expression inside at the beginning of ${ instead of the beginning\n            // of the `.\n            var tabWidth = options.tabWidth;\n            var quasi = childPath.getValue();\n            var indentSize = getIndentSize(quasi.value.raw, tabWidth);\n            var _printed3 = expressions[i];\n\n            if (!isSimple) {\n              // Breaks at the template element boundaries (${ and }) are preferred to breaking\n              // in the middle of a MemberExpression\n              if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                _printed3 = concat([indent(concat([softline, _printed3])), softline]);\n              }\n            }\n\n            var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align(-Infinity, _printed3) : addAlignmentToDoc(_printed3, indentSize, tabWidth);\n            parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));\n          }\n        }, \"quasis\");\n        parts.push(\"`\");\n        return concat(parts);\n      }\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"MemberTypeAnnotation\": // Flow\n\n    case \"Type\":\n      /* istanbul ignore next */\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n    case \"TypeAnnotation\":\n    case \"TSTypeAnnotation\":\n      if (n.typeAnnotation) {\n        return path.call(print, \"typeAnnotation\");\n      }\n      /* istanbul ignore next */\n\n\n      return \"\";\n\n    case \"TSTupleType\":\n    case \"TupleTypeAnnotation\":\n      {\n        var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n        return group(concat([\"[\", indent(concat([softline, printArrayItems(path, options, typesField, print)])), ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), softline, \"]\"]));\n      }\n\n    case \"ExistsTypeAnnotation\":\n      return \"*\";\n\n    case \"EmptyTypeAnnotation\":\n      return \"empty\";\n\n    case \"AnyTypeAnnotation\":\n      return \"any\";\n\n    case \"MixedTypeAnnotation\":\n      return \"mixed\";\n\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"BooleanTypeAnnotation\":\n      return \"boolean\";\n\n    case \"BooleanLiteralTypeAnnotation\":\n      return \"\" + n.value;\n\n    case \"DeclareClass\":\n      return printFlowDeclaration(path, printClass(path, options, print));\n\n    case \"TSDeclareFunction\":\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n      return concat([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare export * from \", path.call(print, \"source\")]);\n\n    case \"DeclareExportDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n\n    case \"DeclareOpaqueType\":\n    case \"OpaqueType\":\n      {\n        parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n        if (n.supertype) {\n          parts.push(\": \", path.call(print, \"supertype\"));\n        }\n\n        if (n.impltype) {\n          parts.push(\" = \", path.call(print, \"impltype\"));\n        }\n\n        parts.push(semi);\n\n        if (n.type === \"DeclareOpaqueType\") {\n          return printFlowDeclaration(path, parts);\n        }\n\n        return concat(parts);\n      }\n\n    case \"FunctionTypeAnnotation\":\n    case \"TSFunctionType\":\n      {\n        // FunctionTypeAnnotation is ambiguous:\n        // declare function foo(a: B): void; OR\n        // var A: (a: B) => void;\n        var _parent7 = path.getParentNode(0);\n\n        var _parentParent2 = path.getParentNode(1);\n\n        var _parentParentParent = path.getParentNode(2);\n\n        var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent7.type === \"ObjectTypeProperty\" || _parent7.type === \"ObjectTypeInternalSlot\") && !getFlowVariance(_parent7) && !_parent7.optional && options.locStart(_parent7) === options.locStart(n) || _parent7.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n        var needsColon = isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n        // printing \":\" as part of the expression and it would put parenthesis\n        // around :(\n\n        var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent7.type === \"TypeAnnotation\" || _parent7.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n        if (isObjectTypePropertyAFunction(_parent7, options)) {\n          isArrowFunctionTypeAnnotation = true;\n          needsColon = true;\n        }\n\n        if (needsParens) {\n          parts.push(\"(\");\n        }\n\n        parts.push(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n        // needs to be added separately.\n\n        if (n.returnType || n.predicate || n.typeAnnotation) {\n          parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n        }\n\n        if (needsParens) {\n          parts.push(\")\");\n        }\n\n        return group(concat(parts));\n      }\n\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n    case \"FunctionTypeParam\":\n      return concat([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n    case \"GenericTypeAnnotation\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"DeclareInterface\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n      {\n        if (n.type === \"DeclareInterface\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(\"interface\");\n\n        if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n          parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n        }\n\n        if (n[\"extends\"].length > 0) {\n          parts.push(group(indent(concat([line, \"extends \", (n[\"extends\"].length === 1 ? identity : indent)(join(concat([\",\", line]), path.map(print, \"extends\")))]))));\n        }\n\n        parts.push(\" \", path.call(print, \"body\"));\n        return group(concat(parts));\n      }\n\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSClassImplements\":\n      return concat([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n    case \"TSIntersectionType\":\n    case \"IntersectionTypeAnnotation\":\n      {\n        var types = path.map(print, \"types\");\n        var result = [];\n        var wasIndented = false;\n\n        for (var _i = 0; _i < types.length; ++_i) {\n          if (_i === 0) {\n            result.push(types[_i]);\n          } else if (isObjectType(n.types[_i - 1]) && isObjectType(n.types[_i])) {\n            // If both are objects, don't indent\n            result.push(concat([\" & \", wasIndented ? indent(types[_i]) : types[_i]]));\n          } else if (!isObjectType(n.types[_i - 1]) && !isObjectType(n.types[_i])) {\n            // If no object is involved, go to the next line if it breaks\n            result.push(indent(concat([\" &\", line, types[_i]])));\n          } else {\n            // If you go from object to non-object or vis-versa, then inline it\n            if (_i > 1) {\n              wasIndented = true;\n            }\n\n            result.push(\" & \", _i > 1 ? indent(types[_i]) : types[_i]);\n          }\n        }\n\n        return group(concat(result));\n      }\n\n    case \"TSUnionType\":\n    case \"UnionTypeAnnotation\":\n      {\n        // single-line variation\n        // A | B | C\n        // multi-line variation\n        // | A\n        // | B\n        // | C\n        var _parent8 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n        var shouldIndent = _parent8.type !== \"TypeParameterInstantiation\" && _parent8.type !== \"TSTypeParameterInstantiation\" && _parent8.type !== \"GenericTypeAnnotation\" && _parent8.type !== \"TSTypeReference\" && _parent8.type !== \"TSTypeAssertion\" && !(_parent8.type === \"FunctionTypeParam\" && !_parent8.name) && !((_parent8.type === \"TypeAlias\" || _parent8.type === \"VariableDeclarator\" || _parent8.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment(options.originalText, n, options)); // {\n        //   a: string\n        // } | null | void\n        // should be inlined and not be printed in the multi-line variant\n\n        var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n        // | child1\n        // // comment\n        // | child2\n\n        var _printed4 = path.map(function (typePath) {\n          var printedType = typePath.call(print);\n\n          if (!shouldHug) {\n            printedType = align(2, printedType);\n          }\n\n          return comments.printComments(typePath, function () {\n            return printedType;\n          }, options);\n        }, \"types\");\n\n        if (shouldHug) {\n          return join(\" | \", _printed4);\n        }\n\n        var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, n, options);\n        var code = concat([ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])), join(concat([line, \"| \"]), _printed4)]);\n        var hasParens;\n\n        if (n.type === \"TSUnionType\") {\n          var _grandParent = path.getNode(2);\n\n          var greatGrandParent = path.getParentNode(2);\n          var greatGreatGrandParent = path.getParentNode(3);\n          hasParens = _parent8.type === \"TSParenthesizedType\" && (_grandParent.type === \"TSAsExpression\" || _grandParent.type === \"TSUnionType\" || _grandParent.type === \"TSIntersectionType\" || _grandParent.type === \"TSTypeOperator\" || _grandParent.type === \"TSArrayType\") || greatGrandParent && greatGrandParent.type === \"TSParenthesizedType\" && greatGreatGrandParent && (greatGreatGrandParent.type === \"TSUnionType\" || greatGreatGrandParent.type === \"TSIntersectionType\");\n        } else {\n          hasParens = pathNeedsParens(path, options);\n        }\n\n        if (hasParens) {\n          return group(concat([indent(code), softline]));\n        }\n\n        return group(shouldIndent ? indent(code) : code);\n      }\n\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNullKeyword\":\n    case \"NullLiteralTypeAnnotation\":\n      return \"null\";\n\n    case \"ThisTypeAnnotation\":\n      return \"this\";\n\n    case \"NumberTypeAnnotation\":\n      return \"number\";\n\n    case \"ObjectTypeCallProperty\":\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      parts.push(path.call(print, \"value\"));\n      return concat(parts);\n\n    case \"ObjectTypeIndexer\":\n      {\n        var _variance = getFlowVariance(n);\n\n        return concat([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n      }\n\n    case \"ObjectTypeProperty\":\n      {\n        var _variance2 = getFlowVariance(n);\n\n        var modifier = \"\";\n\n        if (n.proto) {\n          modifier = \"proto \";\n        } else if (n[\"static\"]) {\n          modifier = \"static \";\n        }\n\n        return concat([modifier, isGetterOrSetter(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n      }\n\n    case \"QualifiedTypeIdentifier\":\n      return concat([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n    case \"StringLiteralTypeAnnotation\":\n      return nodeStr(n, options);\n\n    case \"NumberLiteralTypeAnnotation\":\n      assert.strictEqual(_typeof(n.value), \"number\");\n\n      if (n.extra != null) {\n        return printNumber(n.extra.raw);\n      }\n\n      return printNumber(n.raw);\n\n    case \"StringTypeAnnotation\":\n      return \"string\";\n\n    case \"DeclareTypeAlias\":\n    case \"TypeAlias\":\n      {\n        if (n.type === \"DeclareTypeAlias\" || isNodeStartingWithDeclare(n, options)) {\n          parts.push(\"declare \");\n        }\n\n        var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n        parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n        return group(concat(parts));\n      }\n\n    case \"TypeCastExpression\":\n      {\n        var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n        // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n        // annotations when producing an AST. So to preserve parentheses around type casts that use\n        // the comment syntax, we need to hackily read the source itself to see if the code contains\n        // a type annotation comment.\n        //\n        // Note that we're able to use the normal whitespace regex here because the Flow parser has\n        // already deemed this AST node to be a type cast. Only the Babel parser needs the\n        // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n        // implemented differently.\n\n        var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n        return concat([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n      }\n\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      {\n        var _value = path.getValue();\n\n        var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n        // because we know for sure that this is a type definition.\n\n        var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n        if (_commentSyntax) {\n          return concat([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n        }\n\n        return printTypeParameters(path, options, print, \"params\");\n      }\n\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n\n    case \"TSTypeParameter\":\n    case \"TypeParameter\":\n      {\n        var _parent9 = path.getParentNode();\n\n        if (_parent9.type === \"TSMappedType\") {\n          parts.push(\"[\", path.call(print, \"name\"));\n\n          if (n.constraint) {\n            parts.push(\" in \", path.call(print, \"constraint\"));\n          }\n\n          parts.push(\"]\");\n          return concat(parts);\n        }\n\n        var _variance3 = getFlowVariance(n);\n\n        if (_variance3) {\n          parts.push(_variance3);\n        }\n\n        parts.push(path.call(print, \"name\"));\n\n        if (n.bound) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"bound\"));\n        }\n\n        if (n.constraint) {\n          parts.push(\" extends \", path.call(print, \"constraint\"));\n        }\n\n        if (n[\"default\"]) {\n          parts.push(\" = \", path.call(print, \"default\"));\n        } // Keep comma if the file extension is .tsx and\n        // has one type parameter that isn't extend with any types.\n        // Because, otherwise formatted result will be invalid as tsx.\n\n\n        var _grandParent2 = path.getNode(2);\n\n        if (_parent9.params && _parent9.params.length === 1 && options.filepath && /\\.tsx$/i.test(options.filepath) && !n.constraint && _grandParent2.type === \"ArrowFunctionExpression\") {\n          parts.push(\",\");\n        }\n\n        return concat(parts);\n      }\n\n    case \"TypeofTypeAnnotation\":\n      return concat([\"typeof \", path.call(print, \"argument\")]);\n\n    case \"VoidTypeAnnotation\":\n      return \"void\";\n\n    case \"InferredPredicate\":\n      return \"%checks\";\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n    case \"TSAbstractKeyword\":\n      return \"abstract\";\n\n    case \"TSAnyKeyword\":\n      return \"any\";\n\n    case \"TSAsyncKeyword\":\n      return \"async\";\n\n    case \"TSBooleanKeyword\":\n      return \"boolean\";\n\n    case \"TSBigIntKeyword\":\n      return \"bigint\";\n\n    case \"TSConstKeyword\":\n      return \"const\";\n\n    case \"TSDeclareKeyword\":\n      return \"declare\";\n\n    case \"TSExportKeyword\":\n      return \"export\";\n\n    case \"TSNeverKeyword\":\n      return \"never\";\n\n    case \"TSNumberKeyword\":\n      return \"number\";\n\n    case \"TSObjectKeyword\":\n      return \"object\";\n\n    case \"TSProtectedKeyword\":\n      return \"protected\";\n\n    case \"TSPrivateKeyword\":\n      return \"private\";\n\n    case \"TSPublicKeyword\":\n      return \"public\";\n\n    case \"TSReadonlyKeyword\":\n      return \"readonly\";\n\n    case \"TSSymbolKeyword\":\n      return \"symbol\";\n\n    case \"TSStaticKeyword\":\n      return \"static\";\n\n    case \"TSStringKeyword\":\n      return \"string\";\n\n    case \"TSUndefinedKeyword\":\n      return \"undefined\";\n\n    case \"TSUnknownKeyword\":\n      return \"unknown\";\n\n    case \"TSVoidKeyword\":\n      return \"void\";\n\n    case \"TSAsExpression\":\n      return concat([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n\n    case \"TSPropertySignature\":\n      {\n        if (n[\"export\"]) {\n          parts.push(\"export \");\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n[\"static\"]) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        if (n.computed) {\n          parts.push(\"[\");\n        }\n\n        parts.push(printPropertyKey(path, options, print));\n\n        if (n.computed) {\n          parts.push(\"]\");\n        }\n\n        parts.push(printOptionalToken(path));\n\n        if (n.typeAnnotation) {\n          parts.push(\": \");\n          parts.push(path.call(print, \"typeAnnotation\"));\n        } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility + \" \");\n      }\n\n      if (n[\"export\"]) {\n        parts.push(\"export \");\n      }\n\n      if (n[\"static\"]) {\n        parts.push(\"static \");\n      }\n\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n\n    case \"TSTypeReference\":\n      return concat([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n\n    case \"TSParenthesizedType\":\n      {\n        return path.call(print, \"typeAnnotation\");\n      }\n\n    case \"TSIndexSignature\":\n      {\n        var _parent10 = path.getParentNode();\n\n        return concat([n[\"export\"] ? \"export \" : \"\", n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent10.type === \"ClassBody\" ? semi : \"\"]);\n      }\n\n    case \"TSTypePredicate\":\n      return concat([path.call(print, \"parameterName\"), \" is \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n\n    case \"TSThisType\":\n      return \"this\";\n\n    case \"TSImportType\":\n      return concat([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n\n    case \"TSIndexedAccessType\":\n      return concat([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n      {\n        if (n.type !== \"TSCallSignatureDeclaration\") {\n          parts.push(\"new \");\n        }\n\n        parts.push(group(printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true)));\n\n        if (n.returnType) {\n          var isType = n.type === \"TSConstructorType\";\n          parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n        }\n\n        return concat(parts);\n      }\n\n    case \"TSTypeOperator\":\n      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n    case \"TSMappedType\":\n      {\n        var _shouldBreak2 = hasNewlineInRange(options.originalText, options.locStart(n), options.locEnd(n));\n\n        return group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, n.readonly ? concat([getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak(semi, \"\")])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), options.bracketSpacing ? line : softline, \"}\"]), {\n          shouldBreak: _shouldBreak2\n        });\n      }\n\n    case \"TSMethodSignature\":\n      parts.push(n.accessibility ? concat([n.accessibility, \" \"]) : \"\", n[\"export\"] ? \"export \" : \"\", n[\"static\"] ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n      /* expandArg */\n      false,\n      /* printTypeParams */\n      true));\n\n      if (n.returnType) {\n        parts.push(\": \", path.call(print, \"returnType\"));\n      }\n\n      return group(concat(parts));\n\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSEnumDeclaration\":\n      if (isNodeStartingWithDeclare(n, options)) {\n        parts.push(\"declare \");\n      }\n\n      if (n.modifiers) {\n        parts.push(printTypeScriptModifiers(path, options, print));\n      }\n\n      if (n[\"const\"]) {\n        parts.push(\"const \");\n      }\n\n      parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n      if (n.members.length === 0) {\n        parts.push(group(concat([\"{\", comments.printDanglingComments(path, options), softline, \"}\"])));\n      } else {\n        parts.push(group(concat([\"{\", indent(concat([hardline, printArrayItems(path, options, \"members\", print), shouldPrintComma(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true), hardline, \"}\"])));\n      }\n\n      return concat(parts);\n\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n\n      return concat(parts);\n\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n\n      parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n      if (options.semi) {\n        parts.push(\";\");\n      }\n\n      return group(concat(parts));\n\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n    case \"TSModuleDeclaration\":\n      {\n        var _parent11 = path.getParentNode();\n\n        var isExternalModule = isLiteral(n.id);\n        var parentIsDeclaration = _parent11.type === \"TSModuleDeclaration\";\n        var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n        if (parentIsDeclaration) {\n          parts.push(\".\");\n        } else {\n          if (n.declare === true) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(printTypeScriptModifiers(path, options, print));\n          var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n          // (declare)? global { ... }\n\n          var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n          if (!isGlobalDeclaration) {\n            parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n          }\n        }\n\n        parts.push(path.call(print, \"id\"));\n\n        if (bodyIsDeclaration) {\n          parts.push(path.call(print, \"body\"));\n        } else if (n.body) {\n          parts.push(\" \", group(path.call(print, \"body\")));\n        } else {\n          parts.push(semi);\n        }\n\n        return concat(parts);\n      }\n\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n\n    case \"TSConditionalType\":\n      return printTernaryOperator(path, options, print, {\n        beforeParts: function beforeParts() {\n          return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n        },\n        afterParts: function afterParts() {\n          return [];\n        },\n        shouldCheckJsx: false,\n        conditionalNodeType: \"TSConditionalType\",\n        consequentNodePropertyName: \"trueType\",\n        alternateNodePropertyName: \"falseType\",\n        testNodePropertyName: \"checkType\",\n        breakNested: true\n      });\n\n    case \"TSInferType\":\n      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n    case \"InterpreterDirective\":\n      parts.push(\"#!\", n.value, hardline);\n\n      if (isNextLineEmpty(options.originalText, n, options)) {\n        parts.push(hardline);\n      }\n\n      return concat(parts);\n\n    case \"NGRoot\":\n      return concat([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat([\" //\", n.node.comments[0].value.trimRight()])));\n\n    case \"NGChainedExpression\":\n      return group(join(concat([\";\", line]), path.map(function (childPath) {\n        return hasNgSideEffect(childPath) ? print(childPath) : concat([\"(\", print(childPath), \")\"]);\n      }, \"expressions\")));\n\n    case \"NGEmptyExpression\":\n      return \"\";\n\n    case \"NGQuotedExpression\":\n      return concat([n.prefix, \":\", n.value]);\n\n    case \"NGMicrosyntax\":\n      return concat(path.map(function (childPath, index) {\n        return concat([index === 0 ? \"\" : isNgForOf(childPath.getValue(), index, n) ? \" \" : concat([\";\", line]), print(childPath)]);\n      }, \"body\"));\n\n    case \"NGMicrosyntaxKey\":\n      return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n    case \"NGMicrosyntaxExpression\":\n      return concat([path.call(print, \"expression\"), n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")])]);\n\n    case \"NGMicrosyntaxKeyedExpression\":\n      {\n        var index = path.getName();\n\n        var _parentNode2 = path.getParentNode();\n\n        var shouldNotPrintColon = isNgForOf(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n        return concat([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n      }\n\n    case \"NGMicrosyntaxLet\":\n      return concat([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")])]);\n\n    case \"NGMicrosyntaxAs\":\n      return concat([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n    default:\n      /* istanbul ignore next */\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\n\nfunction isNgForOf(node, index, parentNode) {\n  return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n}\n/** identify if an angular expression seems to have side effects */\n\n\nfunction hasNgSideEffect(path) {\n  return hasNode(path.getValue(), function (node) {\n    switch (node.type) {\n      case undefined:\n        return false;\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n      case \"AssignmentExpression\":\n        return true;\n    }\n  });\n}\n\nfunction printStatementSequence(path, options, print) {\n  var printed = [];\n  var bodyNode = path.getNode();\n  var isClass = bodyNode.type === \"ClassBody\";\n  path.map(function (stmtPath, i) {\n    var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n\n    /* istanbul ignore if */\n\n    if (!stmt) {\n      return;\n    } // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    if (stmt.type === \"EmptyStatement\") {\n      return;\n    }\n\n    var stmtPrinted = print(stmtPath);\n    var text = options.originalText;\n    var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n    if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n      if (stmt.comments && stmt.comments.some(function (comment) {\n        return comment.leading;\n      })) {\n        parts.push(print(stmtPath, {\n          needsSemi: true\n        }));\n      } else {\n        parts.push(\";\", stmtPrinted);\n      }\n    } else {\n      parts.push(stmtPrinted);\n    }\n\n    if (!options.semi && isClass) {\n      if (classPropMayCauseASIProblems(stmtPath)) {\n        parts.push(\";\");\n      } else if (stmt.type === \"ClassProperty\") {\n        var nextChild = bodyNode.body[i + 1];\n\n        if (classChildNeedsASIProtection(nextChild)) {\n          parts.push(\";\");\n        }\n      }\n    }\n\n    if (isNextLineEmpty(text, stmt, options) && !isLastStatement(stmtPath)) {\n      parts.push(hardline);\n    }\n\n    printed.push(concat(parts));\n  });\n  return join(hardline, printed);\n}\n\nfunction printPropertyKey(path, options, print) {\n  var node = path.getNode();\n  var parent = path.getParentNode();\n  var key = node.key;\n\n  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n    var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n      return !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToCoerceToIdentifier(prop, options);\n    });\n    needsQuoteProps.set(parent, objectHasStringProp);\n  }\n\n  if (key.type === \"Identifier\" && !node.computed && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n    // a -> \"a\"\n    var prop = printString(JSON.stringify(key.name), options);\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return prop;\n      }, options);\n    }, \"key\");\n  }\n\n  if (!node.computed && isStringPropSafeToCoerceToIdentifier(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n    // 'a' -> a\n    return path.call(function (keyPath) {\n      return comments.printComments(keyPath, function () {\n        return key.value;\n      }, options);\n    }, \"key\");\n  }\n\n  return path.call(print, \"key\");\n}\n\nfunction printMethod(path, options, print) {\n  var node = path.getNode();\n  var semi = options.semi ? \";\" : \"\";\n  var kind = node.kind;\n  var parts = [];\n\n  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\") {\n    node.value = node;\n  }\n\n  if (node.value.async) {\n    parts.push(\"async \");\n  }\n\n  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n    if (node.value.generator) {\n      parts.push(\"*\");\n    }\n  } else {\n    assert.ok(kind === \"get\" || kind === \"set\");\n    parts.push(kind, \" \");\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n\n  parts.push(key, concat(path.call(function (valuePath) {\n    return [printFunctionTypeParameters(valuePath, options, print), group(concat([printFunctionParams(valuePath, print, options), printReturnType(valuePath, print, options)]))];\n  }, \"value\")));\n\n  if (!node.value.body || node.value.body.length === 0) {\n    parts.push(semi);\n  } else {\n    parts.push(\" \", path.call(print, \"value\", \"body\"));\n  }\n\n  return concat(parts);\n}\n\nfunction couldGroupArg(arg) {\n  return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" || arg.type === \"TSAsExpression\" || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n  // https://github.com/prettier/prettier/issues/4070\n  // export class Thing implements OtherThing {\n  //   do: (type: Type) => Provider<Prop> = memoize(\n  //     (type: ObjectType): Provider<Opts> => {}\n  //   );\n  // }\n  // https://github.com/prettier/prettier/issues/6099\n  // app.get(\"/\", (req, res): void => {\n  //   res.send(\"Hello World!\");\n  // });\n  !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode(arg.body));\n}\n\nfunction shouldGroupLastArg(args) {\n  var lastArg = getLast(args);\n  var penultimateArg = getPenultimate(args);\n  return !hasLeadingComment(lastArg) && !hasTrailingComment(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n  // disable last element expansion.\n  !penultimateArg || penultimateArg.type !== lastArg.type);\n}\n\nfunction shouldGroupFirstArg(args) {\n  if (args.length !== 2) {\n    return false;\n  }\n\n  var firstArg = args[0];\n  var secondArg = args[1];\n  return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n}\n\nfunction isSimpleFlowType(node) {\n  var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n  return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n}\n\nfunction isJestEachTemplateLiteral(node, parentNode) {\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n  var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n  return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n}\n\nfunction printJestEachTemplateLiteral(node, expressions, options) {\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n  var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n  if (headerNames.length > 1 || headerNames.some(function (headerName) {\n    return headerName.length !== 0;\n  })) {\n    var parts = [];\n    var stringifiedExpressions = expressions.map(function (doc) {\n      return \"${\" + printDocToString(doc, Object.assign({}, options, {\n        printWidth: Infinity,\n        endOfLine: \"lf\"\n      })).formatted + \"}\";\n    });\n    var tableBody = [{\n      hasLineBreak: false,\n      cells: []\n    }];\n\n    for (var i = 1; i < node.quasis.length; i++) {\n      var row = tableBody[tableBody.length - 1];\n      var correspondingExpression = stringifiedExpressions[i - 1];\n      row.cells.push(correspondingExpression);\n\n      if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n        row.hasLineBreak = true;\n      }\n\n      if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n        tableBody.push({\n          hasLineBreak: false,\n          cells: []\n        });\n      }\n    }\n\n    var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n      return Math.max(maxColumnCount, row.cells.length);\n    }, headerNames.length);\n    var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n      return 0;\n    });\n    var table = [{\n      cells: headerNames\n    }].concat(tableBody.filter(function (row) {\n      return row.cells.length !== 0;\n    }));\n    table.filter(function (row) {\n      return !row.hasLineBreak;\n    }).forEach(function (row) {\n      row.cells.forEach(function (cell, index) {\n        maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n      });\n    });\n    parts.push(lineSuffixBoundary, \"`\", indent(concat([hardline, join(hardline, table.map(function (row) {\n      return join(\" | \", row.cells.map(function (cell, index) {\n        return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth(cell));\n      }));\n    }))])), hardline, \"`\");\n    return concat(parts);\n  }\n}\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\nfunction isSimpleTemplateLiteral(node) {\n  if (node.expressions.length === 0) {\n    return false;\n  }\n\n  return node.expressions.every(function (expr) {\n    // Disallow comments since printDocToString can't print them here\n    if (expr.comments) {\n      return false;\n    } // Allow `x` and `this`\n\n\n    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n      return true;\n    } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n    if ((expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") && (expr.property.type === \"Identifier\" || expr.property.type === \"Literal\")) {\n      var ancestor = expr;\n\n      while (ancestor.type === \"MemberExpression\" || ancestor.type === \"OptionalMemberExpression\") {\n        ancestor = ancestor.object;\n\n        if (ancestor.comments) {\n          return false;\n        }\n      }\n\n      if (ancestor.type === \"Identifier\" || ancestor.type === \"ThisExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  });\n}\n\nvar functionCompositionFunctionNames = new Set([\"pipe\", // RxJS, Ramda\n\"pipeP\", // Ramda\n\"pipeK\", // Ramda\n\"compose\", // Ramda, Redux\n\"composeFlipped\", // Not from any library, but common in Haskell, so supported\n\"composeP\", // Ramda\n\"composeK\", // Ramda\n\"flow\", // Lodash\n\"flowRight\", // Lodash\n\"connect\", // Redux\n\"createSelector\" // Reselect\n]);\nvar ordinaryMethodNames = new Set([\"connect\" // GObject, MongoDB\n]);\n\nfunction isFunctionCompositionFunction(node) {\n  switch (node.type) {\n    case \"OptionalMemberExpression\":\n    case \"MemberExpression\":\n      {\n        return isFunctionCompositionFunction(node.property) && !ordinaryMethodNames.has(node.property.name);\n      }\n\n    case \"Identifier\":\n      {\n        return functionCompositionFunctionNames.has(node.name);\n      }\n\n    case \"StringLiteral\":\n    case \"Literal\":\n      {\n        return functionCompositionFunctionNames.has(node.value);\n      }\n  }\n}\n\nfunction printArgumentsList(path, options, print) {\n  var node = path.getValue();\n  var args = node.arguments;\n\n  if (args.length === 0) {\n    return concat([\"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true), \")\"]);\n  } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n  if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n    return arg.comments;\n  })) {\n    return concat([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n  } // func(\n  //   ({\n  //     a,\n  //     b\n  //   }) => {}\n  // );\n\n\n  function hasEmptyLineInObjectArgInArrowFunction(arg) {\n    return arg && arg.type === \"ArrowFunctionExpression\" && arg.params && arg.params.some(function (param) {\n      return param.type && param.type === \"ObjectPattern\" && param.properties && param.properties.some(function (property, i, properties) {\n        return i < properties.length - 1 && isNextLineEmpty(options.originalText, property, options);\n      });\n    });\n  }\n\n  var anyArgEmptyLine = false;\n  var hasEmptyLineFollowingFirstArg = false;\n  var lastArgIndex = args.length - 1;\n  var printedArguments = path.map(function (argPath, index) {\n    var arg = argPath.getNode();\n    var parts = [print(argPath)];\n\n    if (index === lastArgIndex) {// do nothing\n    } else if (isNextLineEmpty(options.originalText, arg, options)) {\n      if (index === 0) {\n        hasEmptyLineFollowingFirstArg = true;\n      }\n\n      anyArgEmptyLine = true;\n      parts.push(\",\", hardline, hardline);\n    } else {\n      parts.push(\",\", line);\n    }\n\n    anyArgEmptyLine = hasEmptyLineInObjectArgInArrowFunction(arg);\n    return concat(parts);\n  }, \"arguments\");\n  var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n  !(node.callee && node.callee.type === \"Import\") && shouldPrintComma(options, \"all\") ? \",\" : \"\";\n\n  function allArgsBrokenOut() {\n    return group(concat([\"(\", indent(concat([line, concat(printedArguments)])), maybeTrailingComma, line, \")\"]), {\n      shouldBreak: true\n    });\n  } // We want to get\n  //    pipe(\n  //      x => x + 1,\n  //      x => x - 1\n  //    )\n  // here, but not\n  //    process.stdout.pipe(socket)\n\n\n  if (isFunctionCompositionFunction(node.callee) && args.length > 1) {\n    return allArgsBrokenOut();\n  }\n\n  var shouldGroupFirst = shouldGroupFirstArg(args);\n  var shouldGroupLast = shouldGroupLastArg(args);\n\n  if (shouldGroupFirst || shouldGroupLast) {\n    var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine; // We want to print the last argument with a special flag\n\n    var printedExpanded;\n    var i = 0;\n    path.each(function (argPath) {\n      if (shouldGroupFirst && i === 0) {\n        printedExpanded = [concat([argPath.call(function (p) {\n          return print(p, {\n            expandFirstArg: true\n          });\n        }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : \"\"])].concat(printedArguments.slice(1));\n      }\n\n      if (shouldGroupLast && i === args.length - 1) {\n        printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n          return print(p, {\n            expandLastArg: true\n          });\n        }));\n      }\n\n      i++;\n    }, \"arguments\");\n    var somePrintedArgumentsWillBreak = printedArguments.some(willBreak);\n    var simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);\n    return concat([somePrintedArgumentsWillBreak ? breakParent : \"\", conditionalGroup([!somePrintedArgumentsWillBreak ? simpleConcat : ifBreak(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat([\"(\", group(printedExpanded[0], {\n      shouldBreak: true\n    }), concat(printedExpanded.slice(1)), \")\"]) : concat([\"(\", concat(printedArguments.slice(0, -1)), group(getLast(printedExpanded), {\n      shouldBreak: true\n    }), \")\"]), allArgsBrokenOut()], {\n      shouldBreak: shouldBreak\n    })]);\n  }\n\n  return group(concat([\"(\", indent(concat([softline, concat(printedArguments)])), ifBreak(maybeTrailingComma), softline, \")\"]), {\n    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n  });\n}\n\nfunction printTypeAnnotation(path, options, print) {\n  var node = path.getValue();\n\n  if (!node.typeAnnotation) {\n    return \"\";\n  }\n\n  var parentNode = path.getParentNode();\n  var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n  var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)) {\n    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n  }\n\n  return concat([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n}\n\nfunction printFunctionTypeParameters(path, options, print) {\n  var fun = path.getValue();\n\n  if (fun.typeArguments) {\n    return path.call(print, \"typeArguments\");\n  }\n\n  if (fun.typeParameters) {\n    return path.call(print, \"typeParameters\");\n  }\n\n  return \"\";\n}\n\nfunction printFunctionParams(path, print, options, expandArg, printTypeParams) {\n  var fun = path.getValue();\n  var parent = path.getParentNode();\n  var paramsField = fun.parameters ? \"parameters\" : \"params\";\n  var isParametersInTestCall = isTestCall(parent);\n  var shouldHugParameters = shouldHugArguments(fun);\n  var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n    return n.comments;\n  }));\n  var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n  var printed = [];\n\n  if (fun[paramsField]) {\n    var lastArgIndex = fun[paramsField].length - 1;\n    printed = path.map(function (childPath, index) {\n      var parts = [];\n      var param = childPath.getValue();\n      parts.push(print(childPath));\n\n      if (index === lastArgIndex) {\n        if (fun.rest) {\n          parts.push(\",\", line);\n        }\n      } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n        parts.push(\", \");\n      } else if (isNextLineEmpty(options.originalText, param, options)) {\n        parts.push(\",\", hardline, hardline);\n      } else {\n        parts.push(\",\", line);\n      }\n\n      return concat(parts);\n    }, paramsField);\n  }\n\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n\n  if (printed.length === 0) {\n    return concat([typeParams, \"(\", comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true, function (comment) {\n      return getNextNonSpaceNonCommentCharacter(options.originalText, comment, options.locEnd) === \")\";\n    }), \")\"]);\n  }\n\n  var lastParam = getLast(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we dont want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n  if (shouldExpandParameters) {\n    return group(concat([removeLines(typeParams), \"(\", concat(printed.map(removeLines)), \")\"]));\n  } // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n    return !param.decorators;\n  });\n\n  if (shouldHugParameters && hasNotParameterDecorator) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  if (isParametersInTestCall) {\n    return concat([typeParams, \"(\", concat(printed), \")\"]);\n  }\n\n  var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent, options) || isTypeAnnotationAFunction(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n  if (isFlowShorthandWithOneArg) {\n    if (options.arrowParens === \"always\") {\n      return concat([\"(\", concat(printed), \")\"]);\n    }\n\n    return concat(printed);\n  }\n\n  var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n  return concat([typeParams, \"(\", indent(concat([softline, concat(printed)])), ifBreak(canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \")\"]);\n}\n\nfunction shouldPrintParamsWithoutParens(path, options) {\n  if (options.arrowParens === \"always\") {\n    return false;\n  }\n\n  if (options.arrowParens === \"avoid\") {\n    var node = path.getValue();\n    return canPrintParamsWithoutParens(node);\n  } // Fallback default; should be unreachable\n\n\n  return false;\n}\n\nfunction canPrintParamsWithoutParens(node) {\n  return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n}\n\nfunction printFunctionDeclaration(path, print, options) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n.async) {\n    parts.push(\"async \");\n  }\n\n  parts.push(\"function\");\n\n  if (n.generator) {\n    parts.push(\"*\");\n  }\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printObjectMethod(path, options, print) {\n  var objMethod = path.getValue();\n  var parts = [];\n\n  if (objMethod.async) {\n    parts.push(\"async \");\n  }\n\n  if (objMethod.generator) {\n    parts.push(\"*\");\n  }\n\n  if (objMethod.method || objMethod.kind === \"get\" || objMethod.kind === \"set\") {\n    return printMethod(path, options, print);\n  }\n\n  var key = printPropertyKey(path, options, print);\n\n  if (objMethod.computed) {\n    parts.push(\"[\", key, \"]\");\n  } else {\n    parts.push(key);\n  }\n\n  parts.push(printFunctionTypeParameters(path, options, print), group(concat([printFunctionParams(path, print, options), printReturnType(path, print, options)])), \" \", path.call(print, \"body\"));\n  return concat(parts);\n}\n\nfunction printReturnType(path, print, options) {\n  var n = path.getValue();\n  var returnType = path.call(print, \"returnType\");\n\n  if (n.returnType && isFlowAnnotationComment(options.originalText, n.returnType, options)) {\n    return concat([\" /*: \", returnType, \" */\"]);\n  }\n\n  var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n  if (n.returnType && n.returnType.typeAnnotation) {\n    parts.unshift(\": \");\n  }\n\n  if (n.predicate) {\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n  }\n\n  return concat(parts);\n}\n\nfunction printExportDeclaration(path, options, print) {\n  var decl = path.getValue();\n  var semi = options.semi ? \";\" : \"\";\n  var parts = [\"export \"];\n  var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n  if (isDefault) {\n    parts.push(\"default \");\n  }\n\n  parts.push(comments.printDanglingComments(path, options,\n  /* sameIndent */\n  true));\n\n  if (needsHardlineAfterDanglingComment(decl)) {\n    parts.push(hardline);\n  }\n\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n\n    if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n      parts.push(semi);\n    }\n  } else {\n    if (decl.specifiers && decl.specifiers.length > 0) {\n      var specifiers = [];\n      var defaultSpecifiers = [];\n      var namespaceSpecifiers = [];\n      path.each(function (specifierPath) {\n        var specifierType = path.getValue().type;\n\n        if (specifierType === \"ExportSpecifier\") {\n          specifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportDefaultSpecifier\") {\n          defaultSpecifiers.push(print(specifierPath));\n        } else if (specifierType === \"ExportNamespaceSpecifier\") {\n          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));\n        }\n      }, \"specifiers\");\n      var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n      var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n      var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n        return node.comments;\n      });\n      var printed = \"\";\n\n      if (specifiers.length !== 0) {\n        if (canBreak) {\n          printed = group(concat([\"{\", indent(concat([options.bracketSpacing ? line : softline, join(concat([\",\", line]), specifiers)])), ifBreak(shouldPrintComma(options) ? \",\" : \"\"), options.bracketSpacing ? line : softline, \"}\"]));\n        } else {\n          printed = concat([\"{\", options.bracketSpacing ? \" \" : \"\", concat(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n        }\n      }\n\n      parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat(defaultSpecifiers), concat([isDefaultFollowed ? \", \" : \"\"]), concat(namespaceSpecifiers), concat([isNamespaceFollowed ? \", \" : \"\"]), printed);\n    } else {\n      parts.push(\"{}\");\n    }\n\n    if (decl.source) {\n      parts.push(\" from \", path.call(print, \"source\"));\n    }\n\n    parts.push(semi);\n  }\n\n  return concat(parts);\n}\n\nfunction printFlowDeclaration(path, parts) {\n  var parentExportDecl = getParentExportDeclaration(path);\n\n  if (parentExportDecl) {\n    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n  } else {\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n    parts.unshift(\"declare \");\n  }\n\n  return concat(parts);\n}\n\nfunction getFlowVariance(path) {\n  if (!path.variance) {\n    return null;\n  } // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n  var variance = path.variance.kind || path.variance;\n\n  switch (variance) {\n    case \"plus\":\n      return \"+\";\n\n    case \"minus\":\n      return \"-\";\n\n    default:\n      /* istanbul ignore next */\n      return variance;\n  }\n}\n\nfunction printTypeScriptModifiers(path, options, print) {\n  var n = path.getValue();\n\n  if (!n.modifiers || !n.modifiers.length) {\n    return \"\";\n  }\n\n  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);\n}\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  var n = path.getValue();\n\n  if (!n[paramsKey]) {\n    return \"\";\n  } // for TypeParameterDeclaration typeParameters is a single node\n\n\n  if (!Array.isArray(n[paramsKey])) {\n    return path.call(print, paramsKey);\n  }\n\n  var grandparent = path.getNode(2);\n  var isParameterInTestCall = grandparent != null && isTestCall(grandparent);\n  var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\");\n\n  if (shouldInline) {\n    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);\n  }\n\n  return group(concat([\"<\", indent(concat([softline, join(concat([\",\", line]), path.map(print, paramsKey))])), ifBreak(options.parser !== \"typescript\" && shouldPrintComma(options, \"all\") ? \",\" : \"\"), softline, \">\"]));\n}\n\nfunction printClass(path, options, print) {\n  var n = path.getValue();\n  var parts = [];\n\n  if (n[\"abstract\"]) {\n    parts.push(\"abstract \");\n  }\n\n  parts.push(\"class\");\n\n  if (n.id) {\n    parts.push(\" \", path.call(print, \"id\"));\n  }\n\n  parts.push(path.call(print, \"typeParameters\"));\n  var partsGroup = [];\n\n  if (n.superClass) {\n    var printed = concat([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n    // If there is only on extends and there are not comments\n\n    if ((!n[\"implements\"] || n[\"implements\"].length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n      parts.push(concat([\" \", path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")]));\n    } else {\n      partsGroup.push(group(concat([line, path.call(function (superClass) {\n        return comments.printComments(superClass, function () {\n          return printed;\n        }, options);\n      }, \"superClass\")])));\n    }\n  } else if (n[\"extends\"] && n[\"extends\"].length > 0) {\n    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));\n  }\n\n  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n    partsGroup.push(line, \"mixins \", group(indent(join(concat([\",\", line]), path.map(print, \"mixins\")))));\n  }\n\n  if (n[\"implements\"] && n[\"implements\"].length > 0) {\n    partsGroup.push(line, \"implements\", group(indent(concat([line, join(concat([\",\", line]), path.map(print, \"implements\"))]))));\n  }\n\n  if (partsGroup.length > 0) {\n    parts.push(group(indent(concat(partsGroup))));\n  }\n\n  if (n.body && n.body.comments && hasLeadingOwnLineComment(options.originalText, n.body, options)) {\n    parts.push(hardline);\n  } else {\n    parts.push(\" \");\n  }\n\n  parts.push(path.call(print, \"body\"));\n  return parts;\n}\n\nfunction printOptionalToken(path) {\n  var node = path.getValue();\n\n  if (!node.optional) {\n    return \"\";\n  }\n\n  if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n    return \"?.\";\n  }\n\n  return \"?\";\n}\n\nfunction printMemberLookup(path, options, print) {\n  var property = path.call(print, \"property\");\n  var n = path.getValue();\n  var optional = printOptionalToken(path);\n\n  if (!n.computed) {\n    return concat([optional, \".\", property]);\n  }\n\n  if (!n.property || isNumericLiteral(n.property)) {\n    return concat([optional, \"[\", property, \"]\"]);\n  }\n\n  return group(concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"]));\n}\n\nfunction printBindExpressionCallee(path, options, print) {\n  return concat([\"::\", path.call(print, \"callee\")]);\n} // We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\n\n\nfunction printMemberChain(path, options, print) {\n  // The first phase is to linearize the AST by traversing it down.\n  //\n  //   a().b()\n  // has the following AST structure:\n  //   CallExpression(MemberExpression(CallExpression(Identifier)))\n  // and we transform it into\n  //   [Identifier, CallExpression, MemberExpression, CallExpression]\n  var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n  // the first group whether it is in parentheses or not\n\n  function shouldInsertEmptyLineAfter(node) {\n    var originalText = options.originalText;\n    var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node, options);\n    var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n    // line after that parenthesis\n\n    if (nextChar == \")\") {\n      return isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1, options);\n    }\n\n    return isNextLineEmpty(originalText, node, options);\n  }\n\n  function rec(path) {\n    var node = path.getValue();\n\n    if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n      printedNodes.unshift({\n        node: node,\n        printed: concat([comments.printComments(path, function () {\n          return concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n        }, options), shouldInsertEmptyLineAfter(node) ? hardline : \"\"])\n      });\n      path.call(function (callee) {\n        return rec(callee);\n      }, \"callee\");\n    } else if (isMemberish(node)) {\n      printedNodes.unshift({\n        node: node,\n        needsParens: pathNeedsParens(path, options),\n        printed: comments.printComments(path, function () {\n          return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n        }, options)\n      });\n      path.call(function (object) {\n        return rec(object);\n      }, \"object\");\n    } else if (node.type === \"TSNonNullExpression\") {\n      printedNodes.unshift({\n        node: node,\n        printed: comments.printComments(path, function () {\n          return \"!\";\n        }, options)\n      });\n      path.call(function (expression) {\n        return rec(expression);\n      }, \"expression\");\n    } else {\n      printedNodes.unshift({\n        node: node,\n        printed: path.call(print)\n      });\n    }\n  } // Note: the comments of the root node have already been printed, so we\n  // need to extract this first call without printing them as they would\n  // if handled inside of the recursive call.\n\n\n  var node = path.getValue();\n  printedNodes.unshift({\n    node: node,\n    printed: concat([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n  });\n  path.call(function (callee) {\n    return rec(callee);\n  }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n  // of it.\n  //\n  //   a().b.c().d().e\n  // will be grouped as\n  //   [\n  //     [Identifier, CallExpression],\n  //     [MemberExpression, MemberExpression, CallExpression],\n  //     [MemberExpression, CallExpression],\n  //     [MemberExpression],\n  //   ]\n  // so that we can print it as\n  //   a()\n  //     .b.c()\n  //     .d()\n  //     .e\n  // The first group is the first node followed by\n  //   - as many CallExpression as possible\n  //       < fn()()() >.something()\n  //   - as many array acessors as possible\n  //       < fn()[0][1][2] >.something()\n  //   - then, as many MemberExpression as possible but the last one\n  //       < this.items >.something()\n\n  var groups = [];\n  var currentGroup = [printedNodes[0]];\n  var i = 1;\n\n  for (; i < printedNodes.length; ++i) {\n    if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n      currentGroup.push(printedNodes[i]);\n    } else {\n      break;\n    }\n  }\n\n  if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n    for (; i + 1 < printedNodes.length; ++i) {\n      if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  groups.push(currentGroup);\n  currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n  // a sequence of CallExpression. To compute it, we keep adding things to the\n  // group until we has seen a CallExpression in the past and reach a\n  // MemberExpression\n\n  var hasSeenCallExpression = false;\n\n  for (; i < printedNodes.length; ++i) {\n    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n      // [0] should be appended at the end of the group instead of the\n      // beginning of the next one\n      if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n        continue;\n      }\n\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n\n    if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n      hasSeenCallExpression = true;\n    }\n\n    currentGroup.push(printedNodes[i]);\n\n    if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n      return comment.trailing;\n    })) {\n      groups.push(currentGroup);\n      currentGroup = [];\n      hasSeenCallExpression = false;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  } // There are cases like Object.keys(), Observable.of(), _.values() where\n  // they are the subject of all the chained calls and therefore should\n  // be kept on the same line:\n  //\n  //   Object.keys(items)\n  //     .filter(x => x)\n  //     .map(x => x)\n  //\n  // In order to detect those cases, we use an heuristic: if the first\n  // node is an identifier with the name starting with a capital\n  // letter or just a sequence of _$. The rationale is that they are\n  // likely to be factories.\n\n\n  function isFactory(name) {\n    return /^[A-Z]|^[_$]+$/.test(name);\n  } // In case the Identifier is shorter than tab width, we can keep the\n  // first call in a single line, if it's an ExpressionStatement.\n  //\n  //   d3.scaleLinear()\n  //     .domain([0, 100])\n  //     .range([0, width]);\n  //\n\n\n  function isShort(name) {\n    return name.length <= options.tabWidth;\n  }\n\n  function shouldNotWrap(groups) {\n    var parent = path.getParentNode();\n    var isExpression = parent && parent.type === \"ExpressionStatement\";\n    var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n    if (groups[0].length === 1) {\n      var firstNode = groups[0][0].node;\n      return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n    }\n\n    var lastNode = getLast(groups[0]).node;\n    return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n  }\n\n  var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n  function printGroup(printedGroup) {\n    var printed = printedGroup.map(function (tuple) {\n      return tuple.printed;\n    }); // Checks if the last node (i.e. the parent node) needs parens and print\n    // accordingly\n\n    if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n      return concat([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n    }\n\n    return concat(printed);\n  }\n\n  function printIndentedGroup(groups) {\n    if (groups.length === 0) {\n      return \"\";\n    }\n\n    return indent(group(concat([hardline, join(hardline, groups.map(printGroup))])));\n  }\n\n  var printedGroups = groups.map(printGroup);\n  var oneLine = concat(printedGroups);\n  var cutoff = shouldMerge ? 3 : 2;\n  var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n    return res.concat(group);\n  }, []);\n  var hasComment = flatGroups.slice(1, -1).some(function (node) {\n    return hasLeadingComment(node.node);\n  }) || flatGroups.slice(0, -1).some(function (node) {\n    return hasTrailingComment(node.node);\n  }) || groups[cutoff] && hasLeadingComment(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n  // render everything concatenated together.\n\n  if (groups.length <= cutoff && !hasComment) {\n    return group(oneLine);\n  } // Find out the last node in the first group and check if it has an\n  // empty line after\n\n\n  var lastNodeBeforeIndent = getLast(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n  var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n  var expanded = concat([printGroup(groups[0]), shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n  var callExpressions = printedNodes.map(function (_ref) {\n    var node = _ref.node;\n    return node;\n  }).filter(isCallOrOptionalCallExpression); // We don't want to print in one line if there's:\n  //  * A comment.\n  //  * 3 or more chained calls.\n  //  * Any group but the last one has a hard line.\n  // If the last group is a function it's okay to inline if it fits.\n\n  if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak) ||\n  /**\n   *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n   *       // multi line content\n   *     })\n   */\n  function (lastGroupDoc, lastGroupNode) {\n    return isCallOrOptionalCallExpression(lastGroupNode) && willBreak(lastGroupDoc);\n  }(getLast(printedGroups), getLast(getLast(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n    return n.arguments.some(isFunctionOrArrowExpression);\n  })) {\n    return group(expanded);\n  }\n\n  return concat([// We only need to check `oneLine` because if `expanded` is chosen\n  // that means that the parent group has already been broken\n  // naturally\n  willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\", conditionalGroup([oneLine, expanded])]);\n}\n\nfunction isCallOrOptionalCallExpression(node) {\n  return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n}\n\nfunction isJSXNode(node) {\n  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n}\n\nfunction isEmptyJSXElement(node) {\n  if (node.children.length === 0) {\n    return true;\n  }\n\n  if (node.children.length > 1) {\n    return false;\n  } // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n  var child = node.children[0];\n  return isLiteral(child) && !isMeaningfulJSXText(child);\n} // Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\nvar jsxWhitespaceChars = \" \\n\\r\\t\";\nvar containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\");\nvar matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\"); // Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\nfunction isMeaningfulJSXText(node) {\n  return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n}\n\nfunction conditionalExpressionChainContainsJSX(node) {\n  return Boolean(getConditionalChainContents(node).find(isJSXNode));\n} // If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n\nfunction getConditionalChainContents(node) {\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n  var nonConditionalExpressions = [];\n\n  function recurse(node) {\n    if (node.type === \"ConditionalExpression\") {\n      recurse(node.test);\n      recurse(node.consequent);\n      recurse(node.alternate);\n    } else {\n      nonConditionalExpressions.push(node);\n    }\n  }\n\n  recurse(node);\n  return nonConditionalExpressions;\n} // Detect an expression node representing `{\" \"}`\n\n\nfunction isJSXWhitespaceExpression(node) {\n  return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n}\n\nfunction separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return \"\";\n  }\n\n  if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n    return child.length === 1 ? softline : hardline;\n  }\n\n  return softline;\n}\n\nfunction separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n  if (isFacebookTranslationTag) {\n    return hardline;\n  }\n\n  if (child.length === 1) {\n    return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline : softline;\n  }\n\n  return hardline;\n} // JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\nfunction printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n  var n = path.getValue();\n  var children = []; // using `map` instead of `each` because it provides `i`\n\n  path.map(function (childPath, i) {\n    var child = childPath.getValue();\n\n    if (isLiteral(child)) {\n      var text = rawText(child); // Contains a non-whitespace character\n\n      if (isMeaningfulJSXText(child)) {\n        var words = text.split(matchJsxWhitespaceRegex); // Starts with whitespace\n\n        if (words[0] === \"\") {\n          children.push(\"\");\n          words.shift();\n\n          if (/\\n/.test(words[0])) {\n            var next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n\n          words.shift();\n        }\n\n        var endWhitespace; // Ends with whitespace\n\n        if (getLast(words) === \"\") {\n          words.pop();\n          endWhitespace = words.pop();\n        } // This was whitespace only without a new line.\n\n\n        if (words.length === 0) {\n          return;\n        }\n\n        words.forEach(function (word, i) {\n          if (i % 2 === 1) {\n            children.push(line);\n          } else {\n            children.push(word);\n          }\n        });\n\n        if (endWhitespace !== undefined) {\n          if (/\\n/.test(endWhitespace)) {\n            var _next = n.children[i + 1];\n            children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(children), child, _next));\n          } else {\n            children.push(jsxWhitespace);\n          }\n        } else {\n          var _next2 = n.children[i + 1];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(children), child, _next2));\n        }\n      } else if (/\\n/.test(text)) {\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n        if (text.match(/\\n/g).length > 1) {\n          children.push(\"\");\n          children.push(hardline);\n        }\n      } else {\n        children.push(\"\");\n        children.push(jsxWhitespace);\n      }\n    } else {\n      var printedChild = print(childPath);\n      children.push(printedChild);\n      var _next3 = n.children[i + 1];\n\n      var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText(_next3);\n\n      if (directlyFollowedByMeaningfulText) {\n        var firstWord = rawText(_next3).trim().split(matchJsxWhitespaceRegex)[0];\n        children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n      } else {\n        children.push(hardline);\n      }\n    }\n  }, \"children\");\n  return children;\n} // JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\nfunction printJSXElement(path, options, print) {\n  var n = path.getValue();\n\n  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {\n    return concat([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n  }\n\n  var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n  var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n  if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n    return concat([openingLines, concat(path.map(print, \"children\")), closingLines]);\n  } // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  n.children = n.children.map(function (child) {\n    if (isJSXWhitespaceExpression(child)) {\n      return {\n        type: \"JSXText\",\n        value: \" \",\n        raw: \" \"\n      };\n    }\n\n    return child;\n  });\n  var containsTag = n.children.filter(isJSXNode).length > 0;\n  var containsMultipleExpressions = n.children.filter(function (child) {\n    return child.type === \"JSXExpressionContainer\";\n  }).length > 1;\n  var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n  var forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n  var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n  var jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");\n  var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n  var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n  var containsText = n.children.filter(function (child) {\n    return isMeaningfulJSXText(child);\n  }).length > 0; // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n  for (var i = children.length - 2; i >= 0; i--) {\n    var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n    var isPairOfHardlines = children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === hardline;\n    var isLineFollowedByJSXWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline || children[i + 2] === hardline);\n    var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n    var isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === \"\" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === \"\" && children[i + 2] === softline;\n\n    if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n      children.splice(i, 2);\n    } else if (isJSXWhitespaceFollowedByLine) {\n      children.splice(i + 1, 2);\n    }\n  } // Trim trailing lines (or empty strings)\n\n\n  while (children.length && (isLineNext(getLast(children)) || isEmpty(getLast(children)))) {\n    children.pop();\n  } // Trim leading lines (or empty strings)\n\n\n  while (children.length && (isLineNext(children[0]) || isEmpty(children[0])) && (isLineNext(children[1]) || isEmpty(children[1]))) {\n    children.shift();\n    children.shift();\n  } // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n  var multilineChildren = [];\n  children.forEach(function (child, i) {\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n    if (child === jsxWhitespace) {\n      if (i === 1 && children[i - 1] === \"\") {\n        if (children.length === 2) {\n          // Solitary whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } // Leading whitespace\n\n\n        multilineChildren.push(concat([rawJsxWhitespace, hardline]));\n        return;\n      } else if (i === children.length - 1) {\n        // Trailing whitespace\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {\n        // Whitespace after line break\n        multilineChildren.push(rawJsxWhitespace);\n        return;\n      }\n    }\n\n    multilineChildren.push(child);\n\n    if (willBreak(child)) {\n      forcedBreak = true;\n    }\n  }); // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n  var content = containsText ? fill(multilineChildren) : group(concat(multilineChildren), {\n    shouldBreak: true\n  });\n  var multiLineElem = group(concat([openingLines, indent(concat([hardline, content])), hardline, closingLines]));\n\n  if (forcedBreak) {\n    return multiLineElem;\n  }\n\n  return conditionalGroup([group(concat([openingLines, concat(children), closingLines])), multiLineElem]);\n}\n\nfunction maybeWrapJSXElementInParens(path, elem) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return elem;\n  }\n\n  var NO_WRAP_PARENTS = {\n    ArrayExpression: true,\n    JSXAttribute: true,\n    JSXElement: true,\n    JSXExpressionContainer: true,\n    JSXFragment: true,\n    ExpressionStatement: true,\n    CallExpression: true,\n    OptionalCallExpression: true,\n    ConditionalExpression: true,\n    JsExpressionRoot: true\n  };\n\n  if (NO_WRAP_PARENTS[parent.type]) {\n    return elem;\n  }\n\n  var shouldBreak = matchAncestorTypes(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]);\n  return group(concat([ifBreak(\"(\"), indent(concat([softline, elem])), softline, ifBreak(\")\")]), {\n    shouldBreak: shouldBreak\n  });\n}\n\nfunction isBinaryish(node) {\n  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n}\n\nfunction isMemberish(node) {\n  return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n}\n\nfunction shouldInlineLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    return false;\n  }\n\n  if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n    return true;\n  }\n\n  if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n    return true;\n  }\n\n  if (isJSXNode(node.right)) {\n    return true;\n  }\n\n  return false;\n} // For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\nfunction printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n  var parts = [];\n  var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n  if (isBinaryish(node)) {\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n    if (shouldFlatten(node.operator, node.left.operator)) {\n      // Flatten them out by recursively calling this function.\n      parts = parts.concat(path.call(function (left) {\n        return printBinaryishExpressions(left, print, options,\n        /* isNested */\n        true, isInsideParenthesis);\n      }, \"left\"));\n    } else {\n      parts.push(path.call(print, \"left\"));\n    }\n\n    var shouldInline = shouldInlineLogicalExpression(node);\n    var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment(options.originalText, node.right, options);\n    var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n    var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group(indent(concat([softline, \": \", join(concat([softline, \":\", ifBreak(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n      return align(2, group(arg));\n    }))]))) : \"\";\n    var right = shouldInline ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat([lineBeforeOperator ? softline : \"\", operator, lineBeforeOperator ? \" \" : line, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n    var parent = path.getParentNode();\n    var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n    parts.push(\" \", shouldGroup ? group(right) : right); // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n    if (isNested && node.comments) {\n      parts = comments.printComments(path, function () {\n        return concat(parts);\n      }, options);\n    }\n  } else {\n    // Our stopping case. Simply print the node normally.\n    parts.push(path.call(print));\n  }\n\n  return parts;\n}\n\nfunction printAssignmentRight(leftNode, rightNode, printedRight, options) {\n  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {\n    return indent(concat([hardline, printedRight]));\n  }\n\n  var canBreak = isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) && // do not put values on a separate line from the key in json\n  options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n  if (canBreak) {\n    return group(indent(concat([line, printedRight])));\n  }\n\n  return concat([\" \", printedRight]);\n}\n\nfunction printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n  if (!rightNode) {\n    return printedLeft;\n  }\n\n  var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n  return group(concat([printedLeft, operator, printed]));\n}\n\nfunction adjustClause(node, clause, forceSpace) {\n  if (node.type === \"EmptyStatement\") {\n    return \";\";\n  }\n\n  if (node.type === \"BlockStatement\" || forceSpace) {\n    return concat([\" \", clause]);\n  }\n\n  return indent(concat([line, clause]));\n}\n\nfunction nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n  var raw = rawText(node);\n  var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n  return printString(raw, options, isDirectiveLiteral);\n}\n\nfunction printRegex(node) {\n  var flags = node.flags.split(\"\").sort().join(\"\");\n  return \"/\".concat(node.pattern, \"/\").concat(flags);\n}\n\nfunction isLastStatement(path) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return true;\n  }\n\n  var node = path.getValue();\n  var body = (parent.body || parent.consequent).filter(function (stmt) {\n    return stmt.type !== \"EmptyStatement\";\n  });\n  return body && body[body.length - 1] === node;\n}\n\nfunction hasLeadingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.leading;\n  });\n}\n\nfunction hasTrailingComment(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return comment.trailing;\n  });\n}\n\nfunction hasLeadingOwnLineComment(text, node, options) {\n  if (isJSXNode(node)) {\n    return hasNodeIgnoreComment(node);\n  }\n\n  var res = node.comments && node.comments.some(function (comment) {\n    return comment.leading && hasNewline(text, options.locEnd(comment));\n  });\n  return res;\n}\n\nfunction isFlowAnnotationComment(text, typeAnnotation, options) {\n  var start = options.locStart(typeAnnotation);\n  var end = skipWhitespace(text, options.locEnd(typeAnnotation));\n  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n}\n\nfunction exprNeedsASIProtection(path, options) {\n  var node = path.getValue();\n  var maybeASIProblem = pathNeedsParens(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n  if (maybeASIProblem) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nfunction stmtNeedsASIProtection(path, options) {\n  var node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(function (childPath) {\n    return exprNeedsASIProtection(childPath, options);\n  }, \"expression\");\n}\n\nfunction classPropMayCauseASIProblems(path) {\n  var node = path.getNode();\n\n  if (node.type !== \"ClassProperty\") {\n    return false;\n  }\n\n  var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n  if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n    return true;\n  }\n}\n\nfunction classChildNeedsASIProtection(node) {\n  if (!node) {\n    return;\n  }\n\n  if (node[\"static\"] || node.accessibility // TypeScript\n  ) {\n      return false;\n    }\n\n  if (!node.computed) {\n    var name = node.key && node.key.name;\n\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  switch (node.type) {\n    case \"ClassProperty\":\n    case \"TSAbstractClassProperty\":\n      return node.computed;\n\n    case \"MethodDefinition\": // Flow\n\n    case \"TSAbstractMethodDefinition\": // TypeScript\n\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      {\n        // Babel\n        var isAsync = node.value ? node.value.async : node.async;\n        var isGenerator = node.value ? node.value.generator : node.generator;\n\n        if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n          return false;\n        }\n\n        if (node.computed || isGenerator) {\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      /* istanbul ignore next */\n      return false;\n  }\n} // This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\nfunction returnArgumentHasLeadingComment(options, argument) {\n  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n    return true;\n  }\n\n  if (hasNakedLeftSide(argument)) {\n    var leftMost = argument;\n    var newLeftMost;\n\n    while (newLeftMost = getLeftSide(leftMost)) {\n      leftMost = newLeftMost;\n\n      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isMemberExpressionChain(node) {\n  if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n    return false;\n  }\n\n  if (node.object.type === \"Identifier\") {\n    return true;\n  }\n\n  return isMemberExpressionChain(node.object);\n} // Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\nfunction isObjectTypePropertyAFunction(node, options) {\n  return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !isFunctionNotation(node, options);\n} // TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\nfunction isFunctionNotation(node, options) {\n  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n}\n\nfunction isGetterOrSetter(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n\nfunction sameLocStart(nodeA, nodeB, options) {\n  return options.locStart(nodeA) === options.locStart(nodeB);\n} // Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\nfunction isTypeAnnotationAFunction(node, options) {\n  return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node[\"static\"] && !sameLocStart(node, node.typeAnnotation, options);\n}\n\nfunction isNodeStartingWithDeclare(node, options) {\n  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {\n    return false;\n  }\n\n  return options.originalText.slice(0, options.locStart(node)).match(/declare[ \\t]*$/) || options.originalText.slice(node.range[0], node.range[1]).startsWith(\"declare \");\n}\n\nfunction shouldHugType(node) {\n  if (isSimpleFlowType(node) || isObjectType(node)) {\n    return true;\n  }\n\n  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n    var voidCount = node.types.filter(function (n) {\n      return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n    }).length;\n    var objectCount = node.types.filter(function (n) {\n      return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n      n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n    }).length;\n\n    if (node.types.length - 1 === voidCount && objectCount > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction shouldHugArguments(fun) {\n  return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n}\n\nfunction templateLiteralHasNewLines(template) {\n  return template.quasis.some(function (quasi) {\n    return quasi.value.raw.includes(\"\\n\");\n  });\n}\n\nfunction isTemplateOnItsOwnLine(n, text, options) {\n  return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline(text, options.locStart(n), {\n    backwards: true\n  });\n}\n\nfunction printArrayItems(path, options, printPath, print) {\n  var printedElements = [];\n  var separatorParts = [];\n  path.each(function (childPath) {\n    printedElements.push(concat(separatorParts));\n    printedElements.push(group(print(childPath)));\n    separatorParts = [\",\", line];\n\n    if (childPath.getValue() && isNextLineEmpty(options.originalText, childPath.getValue(), options)) {\n      separatorParts.push(softline);\n    }\n  }, printPath);\n  return concat(printedElements);\n}\n\nfunction hasDanglingComments(node) {\n  return node.comments && node.comments.some(function (comment) {\n    return !comment.leading && !comment.trailing;\n  });\n}\n\nfunction needsHardlineAfterDanglingComment(node) {\n  if (!node.comments) {\n    return false;\n  }\n\n  var lastDanglingComment = getLast(node.comments.filter(function (comment) {\n    return !comment.leading && !comment.trailing;\n  }));\n  return lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment);\n}\n\nfunction isLiteral(node) {\n  return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n}\n\nfunction isStringPropSafeToCoerceToIdentifier(node, options) {\n  return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n}\n\nfunction isNumericLiteral(node) {\n  return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n}\n\nfunction isStringLiteral(node) {\n  return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\nfunction isObjectType(n) {\n  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n}\n\nvar unitTestRe = /^(skip|[fx]?(it|describe|test))$/; // eg; `describe(\"some string\", (done) => {})`\n\nfunction isTestCall(n, parent) {\n  if (n.type !== \"CallExpression\") {\n    return false;\n  }\n\n  if (n.arguments.length === 1) {\n    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n      return isFunctionOrArrowExpression(n.arguments[0]);\n    }\n\n    if (isUnitTestSetUp(n)) {\n      return isAngularTestWrapper(n.arguments[0]);\n    }\n  } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n    if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n      // it(\"name\", () => { ... }, 2500)\n      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n        return false;\n      }\n\n      return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n    }\n  }\n\n  return false;\n}\n\nfunction isSkipOrOnlyBlock(node) {\n  return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n}\n\nfunction isTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\";\n} // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\nfunction isAngularTestWrapper(node) {\n  return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n}\n\nfunction isFunctionOrArrowExpression(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n}\n\nfunction isFunctionOrArrowExpressionWithBody(node) {\n  return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n}\n\nfunction isUnitTestSetUp(n) {\n  var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n  return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n}\n\nfunction isTheOnlyJSXElementInMarkdown(options, path) {\n  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n    return false;\n  }\n\n  var node = path.getNode();\n\n  if (!node.expression || !isJSXNode(node.expression)) {\n    return false;\n  }\n\n  var parent = path.getParentNode();\n  return parent.type === \"Program\" && parent.body.length == 1;\n}\n\nfunction willPrintOwnComments(path\n/*, options */\n) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return (node && (isJSXNode(node) || hasFlowShorthandAnnotationComment(node) || parent && parent.type === \"CallExpression\" && (hasFlowAnnotationComment(node.leadingComments) || hasFlowAnnotationComment(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment(path);\n}\n\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n}\n\nfunction printComment(commentPath, options) {\n  var comment = commentPath.getValue();\n\n  switch (comment.type) {\n    case \"CommentBlock\":\n    case \"Block\":\n      {\n        if (isIndentableBlockComment(comment)) {\n          var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n          // printed as a `lineSuffix` which causes the comments to be\n          // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n          if (comment.trailing && !hasNewline(options.originalText, options.locStart(comment), {\n            backwards: true\n          })) {\n            return concat([hardline, printed]);\n          }\n\n          return printed;\n        }\n\n        var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n        return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n      }\n\n    case \"CommentLine\":\n    case \"Line\":\n      // Print shebangs with the proper comment characters\n      if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n        return \"#!\" + comment.value.trimRight();\n      }\n\n      return \"//\" + comment.value.trimRight();\n\n    default:\n      throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n  return lines.length > 1 && lines.every(function (line) {\n    return line.trim()[0] === \"*\";\n  });\n}\n\nfunction printIndentableBlockComment(comment) {\n  var lines = comment.value.split(\"\\n\");\n  return concat([\"/*\", join(hardline, lines.map(function (line, index) {\n    return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n  })), \"*/\"]);\n}\n\nfunction rawText(node) {\n  // our artifically created AST doesn't have extra property\n  //return node.extra ? node.extra.raw : node.raw;\n  return node.value;\n}\n\nfunction identity(x) {\n  return x;\n}\n\nmodule.exports = {\n  preprocess: preprocess,\n  print: genericPrint,\n  embed: embed,\n  insertPragma: insertPragma,\n  massageAstNode: clean,\n  hasPrettierIgnore: hasPrettierIgnore,\n  willPrintOwnComments: willPrintOwnComments,\n  canAttachComment: canAttachComment,\n  printComment: printComment,\n  isBlockComment: handleComments.isBlockComment,\n  handleComments: {\n    ownLine: handleComments.handleOwnLineComment,\n    endOfLine: handleComments.handleEndOfLineComment,\n    remaining: handleComments.handleRemainingComment\n  }\n};"],"names":["_toConsumableArray","arr","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","Symbol","iterator","Object","from","_iterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","name","test","_unsupportedIterableToArray","TypeError","_nonIterableSpread","len","length","i","arr2","_typeof","obj","assert","comments","_require","getParentExportDeclaration","isExportDeclaration","shouldFlatten","getNextNonSpaceNonCommentCharacter","hasNewline","hasNewlineInRange","getLast","getStringWidth","printString","printNumber","hasIgnoreComment","skipWhitespace","hasNodeIgnoreComment","getPenultimate","startsWithNoLookaheadToken","getIndentSize","matchAncestorTypes","getPreferredQuote","_require2","isNextLineEmpty","isNextLineEmptyAfterIndex","getNextNonSpaceNonCommentCharacterIndex","isIdentifierName","embed","clean","insertPragma","handleComments","pathNeedsParens","_require3","printHtmlBinding","isVueEventBindingExpression","preprocess","_require4","getLeftSide","getLeftSidePathName","hasNakedLeftSide","hasNode","hasFlowAnnotationComment","hasFlowShorthandAnnotationComment","needsQuoteProps","WeakMap","_require5","_require5$builders","builders","concat","join","line","hardline","softline","literalline","group","indent","align","conditionalGroup","fill","ifBreak","breakParent","lineSuffixBoundary","addAlignmentToDoc","dedent","_require5$utils","utils","willBreak","isLineNext","isEmpty","removeLines","printDocToString","printer","uid","shouldPrintComma","options","level","trailingComma","hasNewlineBetweenOrAfterDecorators","node","originalText","locStart","decorators","locEnd","printDecorators","path","print","getValue","map","printTernaryOperator","operatorOptions","currentParent","previousParent","testNode","testNodePropertyName","consequentNode","consequentNodePropertyName","alternateNode","alternateNodePropertyName","parts","jsxMode","parent","getParentNode","forceNoIndent","type","conditionalNodeType","firstNonConditionalParent","lastConditionalParent","shouldCheckJsx","isJSXNode","Boolean","nonConditionalExpressions","recurse","consequent","alternate","push","getConditionalChainContents","find","conditionalExpressionChainContainsJSX","wrap","doc","isNull","value","part","useTabs","Math","max","tabWidth","testDoc","breakClosingParen","computed","beforeParts","afterParts","breakNested","getTypeScriptMappedTypeModifier","tokenNode","keyword","isNgForOf","index","parentNode","key","body","printStatementSequence","printed","bodyNode","getNode","isClass","stmtPath","stmt","stmtPrinted","text","semi","isTheOnlyJSXElementInMarkdown","childPath","exprNeedsASIProtection","stmtNeedsASIProtection","some","comment","leading","needsSemi","typeAnnotation","classPropMayCauseASIProblems","accessibility","isAsync","async","isGenerator","generator","kind","classChildNeedsASIProtection","filter","isLastStatement","printPropertyKey","quoteProps","has","objectHasStringProp","properties","members","prop","isStringLiteral","isStringPropSafeToCoerceToIdentifier","set","parser","get","JSON","stringify","keyPath","printComments","printMethod","ok","valuePath","printFunctionTypeParameters","printFunctionParams","printReturnType","couldGroupArg","arg","elements","returnType","isSimpleFlowType","indexOf","typeParameters","functionCompositionFunctionNames","Set","ordinaryMethodNames","isFunctionCompositionFunction","property","printArgumentsList","args","arguments","printDanglingComments","params","anyArgEmptyLine","hasEmptyLineFollowingFirstArg","lastArgIndex","printedArguments","argPath","param","hasEmptyLineInObjectArgInArrowFunction","maybeTrailingComma","callee","allArgsBrokenOut","shouldBreak","shouldGroupFirst","firstArg","secondArg","shouldGroupFirstArg","shouldGroupLast","lastArg","penultimateArg","hasLeadingComment","hasTrailingComment","shouldGroupLastArg","printedExpanded","each","p","expandFirstArg","expandLastArg","somePrintedArgumentsWillBreak","simpleConcat","printTypeAnnotation","isDefinite","definite","isFunctionDeclarationIdentifier","id","isFlowAnnotationComment","fun","typeArguments","expandArg","printTypeParams","paramsField","parameters","isParametersInTestCall","isTestCall","shouldHugParameters","shouldHugArguments","shouldExpandParameters","typeParams","rest","lastParam","hasNotParameterDecorator","every","isFlowShorthandWithOneArg","isObjectTypePropertyAFunction","sameLocStart","isTypeAnnotationAFunction","arrowParens","canHaveTrailingComma","shouldPrintParamsWithoutParens","hasDanglingComments","optional","predicate","canPrintParamsWithoutParens","printFunctionDeclaration","printObjectMethod","objMethod","method","unshift","printExportDeclaration","decl","isDefault","needsHardlineAfterDanglingComment","declaration","specifiers","defaultSpecifiers","namespaceSpecifiers","specifierPath","specifierType","isNamespaceFollowed","isDefaultFollowed","canBreak","bracketSpacing","exportKind","source","printFlowDeclaration","parentExportDecl","strictEqual","getFlowVariance","variance","printTypeScriptModifiers","modifiers","printTypeParameters","paramsKey","grandparent","shouldHugType","typeName","printClass","partsGroup","superClass","hasLeadingOwnLineComment","printOptionalToken","printMemberLookup","isNumericLiteral","printBindExpressionCallee","isCallOrOptionalCallExpression","containsNonJsxWhitespaceRegex","RegExp","matchJsxWhitespaceRegex","isMeaningfulJSXText","isLiteral","rawText","separatorNoWhitespace","isFacebookTranslationTag","child","childNode","nextNode","closingElement","separatorWithWhitespace","isBinaryish","isMemberish","object","shouldInlineLogicalExpression","right","printBinaryishExpressions","isNested","isInsideParenthesis","operator","left","shouldInline","lineBeforeOperator","rightSuffix","shouldGroup","printAssignmentRight","leftNode","rightNode","printedRight","isMemberExpressionChain","printAssignment","printedLeft","adjustClause","clause","forceSpace","nodeStr","isFlowOrTypeScriptDirectiveLiteral","raw","isDirectiveLiteral","printRegex","flags","split","sort","pattern","trailing","start","end","substr","prefix","regex","apply","isFunctionNotation","isGetterOrSetter","nodeA","nodeB","isNodeStartingWithDeclare","match","range","startsWith","isObjectType","voidCount","types","objectCount","templateLiteralHasNewLines","template","quasis","quasi","includes","isTemplateOnItsOwnLine","backwards","printArrayItems","printPath","printedElements","separatorParts","lastDanglingComment","isBlockComment","unitTestRe","isAngularTestWrapper","isFunctionOrArrowExpression","unitTestSetUpRe","isUnitTestSetUp","isTemplateLiteral","isFunctionOrArrowExpressionWithBody","parentParser","expression","identity","x","module","exports","needsParens","linesWithoutParens","htmlBinding","program","interpreter","programPath","directives","bodyPath","directive","_parent","parentParent","_parts","shouldNotIndent","shouldIndentIfInlining","samePrecedenceSubExpression","hasJSX","groupId","chain","jsxPart","shouldBreakAfterCast","castGroup","exprContents","firstNonMemberParent","_parent2","dangling","nextCharacter","shouldAddSoftLine","printTrailingComma","shouldAddParens","delegate","argument","importKind","local","imported","exported","standalones","grouped","naked","hasContent","hasDirectives","_parent3","_parentParent","finalizer","newLeftMost","leftMost","returnArgumentHasLeadingComment","isNew","isIdentifierWithFlowAnnotation","trailingComments","printedNodes","shouldInsertEmptyLineAfter","nextCharIndex","charAt","rec","groups","currentGroup","hasSeenCallExpression","isFactory","isShort","shouldNotWrap","isExpression","hasComputed","firstNode","lastNode","shouldMerge","printGroup","printedGroup","tuple","printIndentedGroup","printedGroups","oneLine","cutoff","flatGroups","reduce","res","hasComment","lastNodeBeforeIndent","shouldHaveEmptyLineBeforeIndent","expanded","callExpressions","_ref","lastGroupDoc","lastGroupNode","printMemberChain","substring","trim","propertiesField","isTypeAnnotation","fields","firstProperty","field","a","b","_parent4","isFlowInterfaceLikeBody","getName","separator","leftBrace","exact","rightBrace","propsAndLoc","forEach","loc","props","result","shift","inexact","content","lastElem","canHaveTrailingSeparator","parentParentParent","shorthand","_lastElem","needsForcedTrailingComma","_parent5","_parts2","extra","rawValue","grandParent","isTypeScriptDirective","reverse","firstVariable","isParentForLoop","hasValue","declarations","init","declare","_printed","con","opening","commentOnOwnLine","elseOnSameLine","_body","_dangling","printedComments","update","isAwait","doBody","label","handler","hasComments","cases","casePath","caseNode","cons","consequentPath","_final","replace","quote","jsxSingleQuote","_escape","_parent6","_shouldInline","elem","children","isEmptyJSXElement","openingLines","closingLines","isJSXWhitespaceExpression","containsTag","containsMultipleExpressions","containsMultipleAttributes","openingElement","attributes","forcedBreak","rawJsxWhitespace","singleQuote","jsxWhitespace","endWhitespace","words","next","pop","word","undefined","_next","_next2","printedChild","_next3","firstWord","printJSXChildren","containsText","isPairOfEmptyStrings","isPairOfHardlines","isLineFollowedByJSXWhitespace","isJSXWhitespaceFollowedByLine","isDoubleJSXWhitespace","isPairOfHardOrSoftLines","splice","multilineChildren","multiLineElem","printJSXElement","ArrayExpression","JSXAttribute","JSXElement","JSXExpressionContainer","JSXFragment","ExpressionStatement","CallExpression","OptionalCallExpression","ConditionalExpression","JsExpressionRoot","maybeWrapJSXElementInParens","_n","nameHasComments","selfClosing","lastAttrHasTrailingComments","bracketSameLine","jsxBracketSameLine","_shouldBreak","attr","hasOwnLineComment","isOpeningFragment","Error","requiresHardline","readonly","expressions","_parentNode","jestEachTriggerRegex","tag","isJestEachTemplateLiteral","_printed2","headerNames","headerName","stringifiedExpressions","assign","printWidth","Infinity","endOfLine","formatted","tableBody","hasLineBreak","cells","row","correspondingExpression","maxColumnCount","maxColumnWidths","table","cell","repeat","printJestEachTemplateLiteral","isSimple","expr","ancestor","isSimpleTemplateLiteral","indentSize","_printed3","aligned","endsWith","typesField","supertype","impltype","_parent7","_parentParent2","_parentParentParent","isArrowFunctionTypeAnnotation","needsColon","wasIndented","_i","_parent8","shouldIndent","shouldHug","_printed4","typePath","printedType","hasParens","shouldAddStartLine","code","_grandParent","greatGrandParent","greatGreatGrandParent","_variance","_variance2","modifier","proto","_printed5","commentSyntax","_value","commentStart","lastIndexOf","_parent9","constraint","_variance3","bound","_grandParent2","filepath","initializer","_parent10","isTypeOf","qualifier","isType","_shouldBreak2","isExport","_parent11","isExternalModule","parentIsDeclaration","bodyIsDeclaration","textBetweenNodeAndItsId","trimRight","hasNgSideEffect","alias","_parentNode2","shouldNotPrintColon","printPathNoParens","ignoreDecorators","decoratorPath","decorator","_node","trimLeft","massageAstNode","hasPrettierIgnore","prevSibling","candidate","hasJsxIgnoreComment","willPrintOwnComments","leadingComments","canAttachComment","printComment","commentPath","lines","isIndentableBlockComment","printIndentableBlockComment","isInsideFlowComment","ownLine","handleOwnLineComment","handleEndOfLineComment","remaining","handleRemainingComment"],"sourceRoot":""}